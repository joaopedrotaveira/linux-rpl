From 6358907fdaf926ac6e975390358e29cabf325e0e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jo=C3=A3o=20Pedro=20Taveira?= <joao.p.taveira@gmail.com>
Date: Sun, 5 Jan 2014 16:12:15 +0000
Subject: [PATCH 1/3] Added XBee driver support

---
 drivers/net/ieee802154/Kconfig  |    4 +
 drivers/net/ieee802154/Makefile |    1 +
 drivers/net/ieee802154/xbee.c   | 4539 +++++++++++++++++++++++++++++++++++++++
 include/uapi/linux/tty.h        |    1 +
 4 files changed, 4545 insertions(+)
 create mode 100644 drivers/net/ieee802154/xbee.c

diff --git a/drivers/net/ieee802154/Kconfig b/drivers/net/ieee802154/Kconfig
index 08ae465..acc8eb8 100644
--- a/drivers/net/ieee802154/Kconfig
+++ b/drivers/net/ieee802154/Kconfig
@@ -30,6 +30,10 @@ config IEEE802154_FAKELB
 	  This driver can also be built as a module. To do so say M here.
 	  The module will be called 'fakelb'.
 
+config IEEE802154_XBEE
+	depends on IEEE802154_DRIVERS && MAC802154
+	tristate "Xbee UART driver"
+
 config IEEE802154_AT86RF230
         depends on IEEE802154_DRIVERS && MAC802154
         tristate "AT86RF230/231 transceiver driver"
diff --git a/drivers/net/ieee802154/Makefile b/drivers/net/ieee802154/Makefile
index abb0c08..72899e3 100644
--- a/drivers/net/ieee802154/Makefile
+++ b/drivers/net/ieee802154/Makefile
@@ -1,4 +1,5 @@
 obj-$(CONFIG_IEEE802154_FAKEHARD) += fakehard.o
 obj-$(CONFIG_IEEE802154_FAKELB) += fakelb.o
+obj-$(CONFIG_IEEE802154_XBEE) += xbee.o
 obj-$(CONFIG_IEEE802154_AT86RF230) += at86rf230.o
 obj-$(CONFIG_IEEE802154_MRF24J40) += mrf24j40.o
diff --git a/drivers/net/ieee802154/xbee.c b/drivers/net/ieee802154/xbee.c
new file mode 100644
index 0000000..ec349fd
--- /dev/null
+++ b/drivers/net/ieee802154/xbee.c
@@ -0,0 +1,4539 @@
+/*
+ *	Xbee: XBee TTY for Xbee RF 868 OEM using 802.15.4 stack
+ *
+ *	Authors:
+ *	Joao Pedro Taveira	<joao.silva@inov.pt>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+/**
+ * @file main.c
+ *
+ * @date Jun 25, 2013
+ * @author Joao Pedro Taveira
+ */
+
+
+#ifndef __KERNEL__
+#include <stdio.h>
+#include <inttypes.h>
+#include <signal.h>
+#include <termios.h>
+#include <sys/time.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <pthread.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#define BUG() do{exit(1);}while(0);
+
+#ifndef pr_fmt
+#define pr_fmt(fmt) fmt
+#endif
+
+#define KERN_EMERG		"emerg: "	/* system is unusable */
+#define KERN_ALERT		"alert: "	/* action must be taken immediately */
+#define KERN_CRIT		"crit : "	/* critical conditions */
+#define KERN_ERR		"error: "	/* error conditions */
+#define KERN_WARNING	"warn : "	/* warning conditions */
+#define KERN_NOTICE		"notic: "	/* normal but significant condition */
+#define KERN_INFO		"info : "	/* informational */
+#define KERN_DEBUG		"debug: "	/* debug-level messages */
+
+#define printk printf
+
+#define pr_debug(fmt, ...) \
+	printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
+
+#define IEEE802154_ADDR_LEN	8
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#ifdef __GNUC__
+__extension__ typedef __signed__ long long __s64;
+__extension__ typedef unsigned long long __u64;
+#else
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif /* __GNUC__ */
+
+/*
+ * Below are truly Linux-specific types that should never collide with
+ * any application/library that wants linux/types.h.
+ */
+
+#ifdef __CHECKER__
+#define __bitwise__ __attribute__((bitwise))
+#else
+#define __bitwise__
+#endif
+#ifdef __CHECK_ENDIAN__
+#define __bitwise __bitwise__
+#else
+#define __bitwise
+#endif
+
+typedef __u16 __bitwise __le16;
+typedef __u16 __bitwise __be16;
+typedef __u32 __bitwise __le32;
+typedef __u32 __bitwise __be32;
+typedef __u64 __bitwise __le64;
+typedef __u64 __bitwise __be64;
+
+typedef __u16 __bitwise __sum16;
+typedef __u32 __bitwise __wsum;
+
+struct ieee802154_hw_addr_filt {
+	__le16	pan_id;		/* Each independent PAN selects a unique
+				 * identifier. This PAN id allows communication
+				 * between devices within a network using short
+				 * addresses and enables transmissions between
+				 * devices across independent networks.
+				 */
+	__le16	short_addr;
+	uint8_t	ieee_addr[IEEE802154_ADDR_LEN];
+	uint8_t	pan_coord;
+};
+
+struct ieee802154_dev {
+	/* filled by the driver */
+	int	extra_tx_headroom;
+	uint32_t	flags;
+	struct	device *parent;
+
+	/* filled by mac802154 core */
+	struct	ieee802154_hw_addr_filt hw_filt;
+	void	*priv;
+	struct	wpan_phy *phy;
+};
+
+#else
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/completion.h>
+#include <linux/tty.h>
+#include <linux/skbuff.h>
+#include <linux/sched.h>
+#include <linux/netdevice.h>
+#include <net/mac802154.h>
+#include <net/ieee802154.h>
+#include <net/ieee802154_netdev.h>
+#include <net/wpan-phy.h>
+
+#define MAX_DATA_SIZE	127
+
+#endif /* __KERNEL__ */
+
+/*
+ * API Operation
+ *
+ *  Start Del 1B      Len 2-3B      Bytes 4-n        Byte n+1
+ * +------------+  +-----+------+  +------------+  +------------+
+ * |    0x7E    |  | MSB |  LSB |  |API-specifc |  | ChkSum 1B  |
+ * +------------+  +-----+------+  +------------+  +------------+
+ *
+ * Escape characters. When sending or receiving a UART data frame,
+ * specific data values must be escaped (flagged) so they do not
+ * interfere with the data frame sequencing. To escape an
+ * interfering data byte, insert 0x7D and follow it with the byte
+ * to be escaped XOR’d with 0x20.
+ *
+ * Data bytes that need to be escaped:
+ * 	0x7E – Frame Delimiter
+ * 	0x7D – Escape
+ * 	0x11 – XON
+ * 	0x13 – XOFF
+ * Example - Raw UART Data Frame (before escaping interfering bytes): 
+ * 		0x7E 0x00 0x02 0x23 0x11 0xCB
+ * 		0x11 needs to be escaped which results in the following frame: 
+ * 		0x7E 0x00 0x02 0x23 0x7D 0x31 0xCB
+ * Note: In the above example, the length of the raw data (excluding
+ * the checksum) is 0x0002 and the checksum of the non-escaped data
+ * (excluding frame delimiter and length) is calculated as:
+ * 		0xFF - (0x23 + 0x11) = (0xFF - 0x34) = 0xCB.
+ *
+ * Length
+ * 	The length field has two-byte value that specifies the number of
+ * 	bytes that will be contained in the frame data field. It does not
+ * 	include the checksum field.
+ */
+
+#define XBEE_SYSFS_STATS 1
+
+#define XBEE_START_DELIM	0x7E
+#define XBEE_ESCAPE			0x7D
+#define XBEE_XON			0x11
+#define XBEE_XOFF			0x13
+
+#define XBEE_ADDR_LEN		8
+#define XBEE_DEFAULT_BROADCAST_RADIUS 1
+
+#define XBEE_MAX_FRAME_ID		0x3F /* 0011 1111 mask */
+#define XBEE_TRANSMIT_SPLITTED	0x80 /* 1000 0000 mask */
+#define XBEE_TRANSMIT_PART2		0x40 /* 0100 0000 mask */
+
+//typedef enum mode {
+//	MODE_IDLE,
+//	MODE_RX,
+//	MODE_TX,
+//	MODE_CMD,
+//	MODE_SLEEP
+//} xbee_pro_mode_t;
+
+typedef enum recv_state {
+	RECV_STATE_WAIT_START_DELIM,
+	RECV_STATE_WAIT_MSB,
+	RECV_STATE_WAIT_LSB,
+	RECV_STATE_WAIT_DATA,
+	RECV_STATE_WAIT_CHECKSUM
+} xbee_recv_state_t;
+
+enum motes {
+	NOT_SUPPORTED_MOTE = -1,
+	UNKNOWN_MOTE = 0,
+	XBEE_XB08_DP_MOTE = 1,
+	HM_TRP_433D_MOTE,
+	HM_TRP_868D_MOTE,
+	MAX_MOTE
+};
+
+struct xbee_device {
+	/* Relative devices */
+#ifdef __KERNEL__
+	struct tty_struct	*tty;
+	struct ieee802154_dev	*dev;
+	int 			device_driver;
+#else
+	int			tty_fd;
+	const char	*tty_path;
+#endif
+
+#ifdef __KERNEL__
+	struct mutex	mutex;
+#else
+	pthread_mutex_t	mutex;
+#endif /* __KERNEL__ */
+	uint8_t			frame_id_counter;
+
+	int				escaped_mode;
+//	xbee_pro_mode_t mode;
+
+	/* Command (rx) processing */
+	uint16_t		recv_data_size;
+	unsigned int	recv_data_offset;
+	int				recv_data_escape_next;
+	uint8_t			*recv_data;
+	int				recv_state;
+	uint8_t			recv_data_sum;
+
+	wait_queue_head_t		wq;
+	struct workqueue_struct	*frames_workqueue;
+
+#ifndef __KERNEL__
+	int rx_thread_running;
+	int rx_thread_end;
+	pthread_t rx_thread_tid;
+#endif /* !__KERNEL__ */
+
+	u8				dev_addr[IEEE802154_ADDR_LEN];
+	u16				pan_id;
+	//u8				rf_max_payload;
+
+};
+
+static u8 global_lqi = 0;
+
+#define FRAME_TYPE_AT_CMD					0x08
+#define FRAME_TYPE_AT_CMD_QUEUE				0x09
+#define FRAME_TYPE_TRANSMIT_REQ				0x10
+#define FRAME_TYPE_EXPLICIT_ADDR_CMD		0x11
+#define FRAME_TYPE_REMOTE_AT_CMD_REQ		0x17
+#define FRAME_TYPE_AT_CMD_RESP				0x88
+#define FRAME_TYPE_TRANSMIT_STATUS2			0x89
+#define FRAME_TYPE_MODEM_STATUS				0x8A
+#define FRAME_TYPE_TRANSMIT_STATUS1			0x8B
+#define FRAME_TYPE_RECEIVE_PACKET			0x90
+#define FRAME_TYPE_EXPLICIT_RX_INDICATOR	0x91
+#define FRAME_TYPE_NODE_ID_INDICATOR		0x95
+#define FRAME_TYPE_REMOTE_CMD_RESP			0x97
+
+#define FRAME_TYPE_RAW_TRANSMIT_REQ			0x20	/* simple RAW packet */
+#define FRAME_TYPE_RAW_RECEIVE				FRAME_TYPE_RAW_TRANSMIT_REQ
+#define FRAME_TYPE_RAW_TRANSMIT_STATUS		0xA0	/* RAW packet send completion */
+
+#define TRANSMIT_OPTION_DISABLE_ACK(x) (x | 0x01)
+#define TRANSMIT_OPTION_ENABLE_ACK(x) (x & ~0x01)
+
+#define TRANSMIT_OPTION_DISABLE_ROUTE_DISCOVERY(x) (x | 0x02)
+#define TRANSMIT_OPTION_ENABLE_ROUTE_DISCOVERY(x) (x & ~0x02)
+
+typedef char at_command_t[2];
+typedef char at_command_param_t[4];
+
+typedef struct api_generic {
+	uint8_t		api_id;
+} api_frame_generic_t;
+
+typedef struct at_cmd {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	at_command_t at_command;
+	at_command_param_t parameter_value;
+	uint8_t		parameter_value_len;
+} api_frame_at_cmd_t;
+
+typedef struct at_cmd_queue {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	at_command_t at_command;
+	at_command_param_t parameter_value;
+	uint8_t		parameter_value_len;
+} api_frame_at_cmd_queue_t;
+
+typedef struct transmit_req {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	uint8_t		dst_addr[XBEE_ADDR_LEN]; // 0x000000000000FFFF - Broadcast address
+	uint16_t	reserved; 			// 0xFFFE
+	uint8_t		brd_radius;
+	uint8_t		options; 			// bit 0: disable ACK  bit 1: Dont Attempt route Disc
+	uint8_t		*payload;
+	uint8_t		payload_len;
+} api_frame_transmit_req_t;
+
+typedef struct raw_packet {
+	uint8_t		api_id;
+	union {
+		uint8_t		frame_id;
+		uint8_t		lqi;
+	};
+	uint8_t		*payload;
+	uint8_t		payload_len;
+} api_frame_raw_packet_t;
+
+typedef struct explicit_addr_cmd {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	uint8_t		dst_addr[XBEE_ADDR_LEN]; // 0x000000000000FFFF - Broadcast address
+	uint16_t	reserved; 			// 0xFFFE
+	uint8_t		src_endpoint;
+	uint8_t		dst_endpoint;
+	uint16_t	cluster_id;
+	uint16_t	profile_id;
+	uint8_t		brd_radius;
+	uint8_t		options; 			// bit 0: disable ACK  bit 1: Dont Attempt route Disc
+	uint8_t		*payload;
+	uint8_t		payload_len;
+} api_frame_explicit_addr_cmd_t;
+
+typedef struct remote_at_cmd_req {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	uint8_t		dst_addr[XBEE_ADDR_LEN]; // 0x000000000000FFFF - Broadcast address
+	uint16_t	reserved; 			// 0xFFFE
+	uint8_t		remote_options;		// 0x02 - Apply changes on remote. (If not set, AC command must be sent before changes will take effect.) All other bits must be set to 0.
+	at_command_t at_command;
+	at_command_param_t parameter_value;
+	uint8_t		parameter_value_len;
+} api_frame_remote_at_cmd_req_t;
+
+typedef struct at_cmd_resp {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	at_command_t at_command;
+	uint8_t		cmd_status;			// 0 = OK; 1 = ERROR; 2 = Invalid Command; 3 = Invalid Parameter
+	at_command_param_t		cmd_data;
+	uint8_t		cmd_data_len;
+} api_frame_at_cmd_resp_t;
+
+typedef struct modem_status {
+	uint8_t		api_id;
+	uint8_t		status;
+	// 0x00: Hardware reset
+	// 0x01: Watchdog timer reset
+	// 0x0B: Network woke up
+	// 0x0C: Network went to sleep
+} api_frame_modem_status_t;
+
+typedef struct transmit_status {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	uint16_t	reserved; 			// 0xFFFE
+	uint8_t		transmit_retry_count; // #transmission retries took place
+	uint8_t		delivery_status;
+	// 0x00 = Success
+	// 0x01 = MAC ACK Failure
+	// 0x15 = Invalid destination endpoint
+	// 0x21 = Network ACK Failure
+	// 0x25 = Route Not Found
+	uint8_t		discovery_status;
+	// 0x00 = No Discovery Overhead
+	// 0x02 = Route Discovery
+} api_frame_transmit_status1_t;
+
+typedef struct transmit_status2 {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	uint8_t		delivery_status;
+	// 0x00 - Success, no errors were detected on transmission.
+	// 0x01 - An expected MAC acknowledgment never occurred.
+	// 0x02 - CCA failure.
+	// 0x03 - Transmission was purged because it was attempted before the stack was up.
+	// 0x04 - Physical error occurred on the interface with the WiFi transceiver.
+	// 0x18 - No Buffers.
+	// 0x03 - Packet was purged without being transmitted.
+	// 0x21 - An expected network acknowledgment never occurred.
+	// 0x22 - Not joined to network.
+	// 0x23 - Self-addressed.
+	// 0x24 - Address not found.
+	// 0x25 - Route not found.
+	// 0x26 - Broadcast relay was not heard.
+	// 0x2B - Invalid Binding Table Index.
+	// 0x2C - Invalid Endpoint.
+	// 0x31 - A software error occurred.
+	// 0x32 - Resource Error.
+	// 0x74 - Data payload too large.
+	// 0x76 - Attempt to create a client socket failed.
+	// 0xBB - Key not authorized.
+} api_frame_transmit_status2_t;
+
+typedef struct raw_transmit_status {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	uint8_t		retries;
+	uint8_t		delivery_status;
+} api_frame_raw_transmit_status_t;
+
+typedef struct receive_packet {
+	uint8_t		api_id;
+	uint8_t		src_addr[XBEE_ADDR_LEN];
+	uint16_t	reserved; 		// 0xFFFE
+	uint8_t		options;		// 0x01 - Packet Acknowledged; 0x02 - Packet was a broadcast packet
+	uint8_t		*payload;
+	uint8_t		payload_len;
+} api_frame_receive_packet_t;
+
+typedef struct explicit_rx_indicator {
+	uint8_t		api_id;
+	uint8_t		src_addr[XBEE_ADDR_LEN];
+	uint16_t	reserved; 		// 0xFFFE
+	uint8_t		src_endpoint;
+	uint8_t		dst_endpoint;
+	uint16_t	cluster_id;
+	uint16_t	profile_id;
+	uint8_t		options;		// 0x01 - Packet Acknowledged; 0x02 - Packet was a broadcast packet
+	uint8_t		*payload;
+	uint8_t		payload_len;
+} api_frame_explicit_rx_indicator_t;
+
+typedef struct node_id_indicator {
+	uint8_t		api_id;
+	uint8_t		sender_addr[XBEE_ADDR_LEN]; // 64bit addr sender
+	uint16_t	sender_short_addr;	// 16bit addr senders
+	uint8_t		options;		// 0x01 - Packet Acknowledged; 0x02 - Packet was a broadcast packet
+	uint16_t	src_short_addr;		// Set to the 16-bit network address of the remote. Set to 0xFFFE if unknown.
+	uint8_t		src_addr[XBEE_ADDR_LEN];
+	unsigned char *ni_string;
+	uint16_t	parent_short_addr;
+} api_frame_node_id_indicator_t;
+
+typedef struct remote_cmd_resp {
+	uint8_t		api_id;
+	uint8_t		frame_id;
+	uint8_t		src_addr[XBEE_ADDR_LEN];
+	uint16_t	reserved; 		// 0xFFFE
+	at_command_t at_command;
+	uint8_t		cmd_status;			// 0 = OK; 1 = ERROR; 2 = Invalid Command; 3 = Invalid Parameter
+	at_command_param_t cmd_data;
+	uint8_t		cmd_data_len;
+} api_frame_remote_cmd_resp_t;
+
+typedef struct xbee_api_frame {
+	uint16_t	len;
+	uint8_t		api_id;
+	uint8_t		*raw_data;
+	union api_cmd_data_union {
+		api_frame_generic_t api_generic;
+		api_frame_at_cmd_t at_cmd;
+		api_frame_at_cmd_queue_t at_cmd_queue;
+		api_frame_transmit_req_t transmit_req;
+		api_frame_explicit_addr_cmd_t explitcit_addr_cmd;
+		api_frame_remote_at_cmd_req_t remote_at_cmd_req;
+		api_frame_at_cmd_resp_t at_cmd_resp;
+		api_frame_modem_status_t modem_status;
+		api_frame_transmit_status1_t transmit_status;
+		api_frame_transmit_status2_t transmit_status2;
+		api_frame_receive_packet_t receive_packet;
+		api_frame_explicit_rx_indicator_t explicit_rx_indicator;
+		api_frame_node_id_indicator_t node_id_indicator;
+		api_frame_remote_cmd_resp_t remote_cmd_resp;
+
+		api_frame_raw_packet_t raw_packet;
+		api_frame_raw_transmit_status_t raw_transmit_status;
+	} *api_data;
+	uint8_t		checksum;
+
+#ifdef __KERNEL__
+	struct completion	complete;
+	struct mutex		mutex;
+#else
+	pthread_cond_t complete;
+	pthread_mutex_t	mutex;
+#endif
+	struct xbee_api_frame *response;
+
+} _api_frame_t;
+
+/*
+ * TTY Helpers
+ */
+
+#ifndef __KERNEL__
+
+/*
+ * functions from:
+ * http://stackoverflow.com/questions/6947413/how-to-open-read-and-write-from-serial-port-in-c
+ */
+
+static int set_interface_attribs(int fd, int speed, int parity) {
+	struct termios tty;
+	memset(&tty, 0, sizeof tty);
+	if (tcgetattr(fd, &tty) != 0) {
+		printk(KERN_ERR "%s(): error %d from tcgetattr", __func__, errno);
+		return -1;
+	}
+
+	cfsetospeed(&tty, speed);
+	cfsetispeed(&tty, speed);
+
+	tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;     // 8-bit chars
+	// disable IGNBRK for mismatched speed tests; otherwise receive break
+	// as \000 chars
+	tty.c_iflag &= ~IGNBRK;         // ignore break signal
+	tty.c_lflag = 0;                // no signaling chars, no echo,
+									// no canonical processing
+	tty.c_oflag = 0;                // no remapping, no delays
+	tty.c_cc[VMIN] = 0;            // read doesn't block
+	tty.c_cc[VTIME] = 5;            // 0.5 seconds read timeout
+
+	tty.c_iflag &= ~(IXON | IXOFF | IXANY); // shut off xon/xoff ctrl
+
+	tty.c_cflag |= (CLOCAL | CREAD); // ignore modem controls,
+									 // enable reading
+	tty.c_cflag &= ~(PARENB | PARODD);      // shut off parity
+	tty.c_cflag |= parity;
+	tty.c_cflag &= ~CSTOPB;
+	tty.c_cflag &= ~CRTSCTS;
+
+	if (tcsetattr(fd, TCSANOW, &tty) != 0) {
+		printk(KERN_ERR "%s(): error %d from tcsetattr", __func__, errno);
+		return -1;
+	}
+	return 0;
+}
+
+static void
+set_blocking (int fd, int should_block)
+{
+	struct termios tty;
+	memset(&tty, 0, sizeof tty);
+	if (tcgetattr(fd, &tty) != 0) {
+		printk(KERN_ERR "%s(): error %d from tggetattr", __func__, errno);
+		return;
+	}
+
+	tty.c_cc[VMIN] = should_block ? 1 : 0;
+	tty.c_cc[VTIME] = 5;            // 0.5 seconds read timeout
+
+	if (tcsetattr(fd, TCSANOW, &tty) != 0)
+		printk(KERN_ERR "%s(): error %d setting term attributes", __func__,
+				errno);
+}
+
+
+/*
+ * XBee Dev helpers
+ */
+static
+struct xbee_device *xbee_device_new()
+{
+	struct xbee_device *xbee_dev;
+#ifdef __KERNEL__
+	xbee_dev = kzalloc(sizeof(struct xbee_device),GFP_KERNEL);
+#else
+	xbee_dev = calloc(1,sizeof(struct xbee_device));
+#endif
+	if(!xbee_dev)
+	{
+		printk(KERN_ERR "%s(): unable to allocate memory\n", __func__);
+		BUG();
+	}
+	xbee_dev->escaped_mode = 1;
+	xbee_dev->frame_id_counter = 1;
+	xbee_dev->recv_state = RECV_STATE_WAIT_START_DELIM;
+//	xbee_dev->rf_max_payload = 100;
+
+#ifdef __KERNEL__
+	mutex_init(&xbee_dev->mutex);
+#else
+	pthread_mutex_init(&xbee_dev->mutex,NULL);
+#endif
+
+	return xbee_dev;
+}
+
+static
+void xbee_device_release(struct xbee_device *xbee_dev)
+{
+	if(!xbee_dev)
+	{
+		printk(KERN_ERR "%s: xbee_dev NULL pointer\n", __func__);
+		BUG();
+	}
+	if(xbee_dev->recv_data)
+	{
+#ifdef __KERNEL__
+		kfree(xbee_dev->recv_data);
+#else
+		free(xbee_dev->recv_data);
+#endif
+		xbee_dev->recv_data = NULL;
+	}
+
+#ifndef __KERNEL__
+	pthread_mutex_destroy(&xbee_dev->mutex);
+#endif
+
+#ifndef __KERNEL__
+	if(xbee_dev->tty_fd>0)
+	{
+		close(xbee_dev->tty_fd);
+	}
+#endif
+
+#ifdef __KERNEL__
+	kfree(xbee_dev);
+#else
+	free(xbee_dev);
+#endif
+	xbee_dev = NULL;
+}
+
+#endif /* !__KERNEL__ */
+
+#ifdef __KERNEL__
+#ifdef XBEE_SYSFS_STATS
+typedef struct xbee_mac_stat {
+	int 			defined;
+	u8				addr[XBEE_ADDR_LEN];
+	unsigned long	last_update; // in jiffies
+	u8				last_lqi;
+} xbee_mac_stat_t;
+
+#define XBEE_MOTE_MAXCOUNT 256
+typedef struct xbee_mac_stats {
+	struct mutex	mutex;
+	xbee_mac_stat_t	mote[XBEE_MOTE_MAXCOUNT];
+} xbee_stats_t;
+
+static xbee_stats_t *stats = NULL;
+
+int xbee_addr_equals(u8 addr1[XBEE_ADDR_LEN], u8 addr2[XBEE_ADDR_LEN])
+{
+	int i = 0;
+	for(i=0;i<XBEE_ADDR_LEN;i++)
+	{
+		if(addr1[i] != addr2[i])
+			return 0;
+	}
+	return 1;
+}
+
+xbee_mac_stat_t *xbee_stat_get_unsafe(u8 addr[XBEE_ADDR_LEN])
+{
+	int i = 0;
+	xbee_mac_stat_t *mac_stat = NULL;
+	for(i=0;i<XBEE_MOTE_MAXCOUNT;i++)
+	{
+		mac_stat = &stats->mote[i];
+		if(!mac_stat->defined)
+		{
+			memcpy(mac_stat->addr,addr, XBEE_ADDR_LEN);
+			mac_stat->defined = 1;
+			break;
+		} else if(xbee_addr_equals(addr,mac_stat->addr)){
+			break;
+		}
+	}
+	return mac_stat;
+}
+
+int xbee_stat_update_lqi(u8 addr[XBEE_ADDR_LEN], u8 lqi)
+{
+	xbee_mac_stat_t *mac_stat = NULL;
+	mutex_lock(&stats->mutex);
+	mac_stat = xbee_stat_get_unsafe(addr);
+	if(mac_stat)
+	{
+		mac_stat->last_lqi = lqi;
+		mac_stat->last_update = jiffies;
+	}
+	mutex_unlock(&stats->mutex);
+	return 0;
+}
+
+static const char *
+eui64_address_to_str(uint8_t addr[XBEE_ADDR_LEN],char eui64_addr_str[24]);
+
+#define XBEE_LQI_TABLE_MAX_LEN 4096
+
+static ssize_t
+xbee_stat_get_lqi_table(char str[XBEE_LQI_TABLE_MAX_LEN])
+{
+	ssize_t count = 0;
+	ssize_t len = 0;
+	int i = 0;
+	unsigned long now = jiffies;
+	unsigned long diff = 0;
+	xbee_mac_stat_t *mac_stat = NULL;
+	char eui64_addr_str[24] = {};
+	mutex_lock(&stats->mutex);
+	for(i = 0;i<XBEE_MOTE_MAXCOUNT; i++)
+	{
+		mac_stat = &stats->mote[i];
+		if(mac_stat && mac_stat->defined)
+		{
+			diff = (long) now - (long) mac_stat->last_update;
+			count = sprintf(str+len,"%s\t%6ld ms\t%3d (0x%02X)\n",eui64_address_to_str(mac_stat->addr,eui64_addr_str),diff * 1000 / HZ, mac_stat->last_lqi,mac_stat->last_lqi);
+			len += count;
+		}
+	}
+	mutex_unlock(&stats->mutex);
+	return len;
+}
+
+static int xbee_stats_init(void){
+	stats = kzalloc(sizeof(xbee_stats_t),GFP_KERNEL);
+	if(!stats)
+		return -ENOMEM;
+	mutex_init(&stats->mutex);
+	return 0;
+}
+
+static int xbee_stats_tini(void) {
+	if(stats)
+		kfree(stats);
+	return 0;
+}
+
+#endif
+#endif
+
+static uint8_t
+_xbee_device_gen_frame_id(struct xbee_device *xbee_dev)
+{
+	uint8_t frame_id;
+	if(!xbee_dev)
+		return 0;
+#ifdef __KERNEL__
+	mutex_lock(&xbee_dev->mutex);
+#else
+	pthread_mutex_lock(&xbee_dev->mutex);
+#endif
+	frame_id = xbee_dev->frame_id_counter = (xbee_dev->frame_id_counter+1)%XBEE_MAX_FRAME_ID;
+	if(frame_id == 0)
+	{
+		frame_id = xbee_dev->frame_id_counter = 1;
+	}
+#ifdef __KERNEL__
+	mutex_unlock(&xbee_dev->mutex);
+#else
+	pthread_mutex_unlock(&xbee_dev->mutex);
+#endif
+	return frame_id;
+}
+
+
+static int escape_required(uint8_t c);
+
+#ifndef __KERNEL__
+static int
+xbee_device_write_to_phy(struct xbee_device *xbee_dev, unsigned char *buf, unsigned int len)
+{
+	int i = 0;
+	uint8_t raw_byte = 0;
+	uint8_t escape_value = XBEE_ESCAPE;
+	unsigned char *raw_data = (unsigned char *) buf;
+	for(i = 0;i<len;i++){
+		raw_byte = ((unsigned char)*(raw_data+i));
+		if(i > 2 && xbee_dev->escaped_mode && escape_required(raw_byte))
+		{
+			//printf("%02X ",XBEE_ESCAPE);
+			write(xbee_dev->tty_fd,&escape_value,1);
+			raw_byte = raw_byte^0x20;
+		}
+		write(xbee_dev->tty_fd,&raw_byte,1);
+		//printf("%02X ",raw_byte);
+	}
+	printf("\n");
+	return len;
+}
+
+static int
+xbee_device_init(struct xbee_device *xbee_dev)
+{
+	if(!xbee_dev)
+	{
+		printk(KERN_ERR "%s: xbee_dev NULL pointer\n", __func__);
+		BUG();
+	}
+#ifndef __KERNEL__
+	if((xbee_dev->tty_fd = open(xbee_dev->tty_path,O_RDWR | O_NOCTTY | O_SYNC)) < 0)
+	{
+		printk(KERN_ERR "%s: error opening tty %s: %s\n", __func__, xbee_dev->tty_path,strerror(errno));
+		return -1;
+	}
+
+	set_interface_attribs (xbee_dev->tty_fd, B9600, 0);  // set speed to 115,200 bps, 8n1 (no parity)
+	set_blocking (xbee_dev->tty_fd, 0);                // set no blocking
+#endif /* !__KERNEL__ */
+	return 0;
+}
+#endif /* !__KERNEL__ */
+
+#ifdef __KERNEL__
+
+#define XBEE_FRAME_MAX_SIZE 255
+
+static struct mote_id {
+	int 	type;
+	u8		id[4];
+	char	*description;
+} mote_ids[4] = {
+		{
+				.type = XBEE_XB08_DP_MOTE,
+				.id = {0x00,0x06,0x00,0x00},
+				.description = "XBee 868 point to multi-point (868MHz for EU market)",
+		},
+		{
+				.type = HM_TRP_433D_MOTE,
+				.id = {0xFF,0xFF,0x00,0x43},
+				.description = "HM-TRP Series 100mW Transceiver modules (HM-TRP-433D)",
+		},
+		{
+				.type = HM_TRP_868D_MOTE,
+				.id = {0xFF,0xFF,0x00,0x86},
+				.description = "HM-TRP Series 100mW Transceiver modules (HM-TRP-868D)",
+		},
+		{
+				.type = NOT_SUPPORTED_MOTE,
+				.id = {0x00,0x00,0x00,0x00},
+				.description = "Not supported device",
+		},
+};
+
+int mote_id_equals(u8 id1[4], u8 id2[4]){
+	int i = 0;
+	for(i=0;i<4;i++){
+		if(id1[i] != id2[i])
+			return 0;
+	}
+	return 1;
+}
+
+static int
+xbee_api_at_command_read_u32(struct xbee_device *xbee_dev, const char cmdid[3], uint8_t value[4]);
+
+static int
+xbee_device_get_type(struct xbee_device *xbee_dev){
+	int mote_type = UNKNOWN_MOTE;
+	u8 mote_id[4] = {0};
+	int i = 0;
+	int err = 0;
+	mutex_lock(&xbee_dev->mutex);
+	mote_type = xbee_dev->device_driver;
+	mutex_unlock(&xbee_dev->mutex);
+	if(mote_type != UNKNOWN_MOTE){
+		return mote_type;
+	}
+	err = xbee_api_at_command_read_u32(xbee_dev,"DD",mote_id);
+	if(err) {
+		printk(KERN_ERR "%s: error getting device type\n", __func__);
+		return err;
+	}
+	else {
+		print_hex_dump_bytes("xbee_device_get_type(): device type: ", DUMP_PREFIX_NONE, mote_id, 4);
+	}
+	while(mote_type != NOT_SUPPORTED_MOTE){
+		mote_type = mote_ids[i].type;
+		//printk(KERN_INFO "%s: checking type: %d: %s\n", __func__,mote_ids[i].type,mote_ids[i].description);
+		//print_hex_dump_bytes("xbee_device_get_type(): checking: ", DUMP_PREFIX_NONE, mote_ids[i].id, 4);
+		if(mote_id_equals(mote_ids[i].id,mote_id) || mote_type == NOT_SUPPORTED_MOTE){
+			mutex_lock(&xbee_dev->mutex);
+			xbee_dev->device_driver = mote_type;
+			mutex_unlock(&xbee_dev->mutex);
+			printk(KERN_INFO "xbee: found mote: %s\n", mote_ids[i].description);
+			break;
+		}
+		i++;
+	}
+	return mote_type;
+}
+
+static int
+xbee_device_write_to_phy(struct xbee_device *xbee_dev, unsigned char *buf, unsigned int len){
+	struct tty_struct *tty;
+	unsigned int sent = 0;
+
+	int i = 0;
+	u8 raw_byte = 0;
+	u8 escape_value = XBEE_ESCAPE;
+	unsigned char *raw_data = (unsigned char *) buf;
+
+	BUG_ON(!xbee_dev);
+	tty = xbee_dev->tty;
+	if (!tty)
+		return -ENODEV;
+
+	/* Debug info */
+	pr_debug("%s(): %d bytes frame\n", __func__, len);
+#ifdef DEBUG
+	print_hex_dump_bytes("send_pending_data ", DUMP_PREFIX_NONE,
+			buf, len);
+#endif
+
+	pr_debug("%s(): sending %d\n", __func__,len);
+	for(i = 0;i<len;i++){
+		raw_byte = ((unsigned char)*(raw_data+i));
+		if(i > 0 && xbee_dev->escaped_mode && escape_required(raw_byte))
+		{
+			if (tty->driver->ops->write(tty, &escape_value,1) != 1) {
+				printk(KERN_ERR "%s: device write failed\n", __func__);
+				return -1;
+			}
+			raw_byte = raw_byte^0x20;
+		}
+		if (tty->driver->ops->write(tty, &raw_byte,1) != 1) {
+			printk(KERN_ERR "%s: device write failed\n", __func__);
+			return -1;
+		}
+		sent++;
+	}
+	return sent;
+}
+#endif /* __KERNEL__ */
+
+static _api_frame_t *temporary_frames_list[1000] = {};
+static int
+_api_frame_should_wait_response(_api_frame_t *api_frame);
+
+static int
+xbee_device_add_pendent_req(struct xbee_device *xbee_dev, _api_frame_t *api_frame)
+{
+	int index = 0;
+
+	if(xbee_dev == NULL)
+	{
+		printk(KERN_ERR "%s: xbee_dev NULL pointer\n", __func__);
+		BUG();
+	}
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: api_frame NULL pointer\n", __func__);
+		BUG();
+	}
+
+#ifdef __KERNEL__
+	//if (mutex_lock_interruptible(&xbee_dev->mutex))
+	//	return -EINTR;
+	mutex_lock(&xbee_dev->mutex);
+#else
+	if(pthread_mutex_lock(&xbee_dev->mutex))
+		return -EINTR;
+#endif
+
+	index = _api_frame_should_wait_response(api_frame);
+	temporary_frames_list[index] = api_frame;
+
+#ifdef __KERNEL__
+	mutex_unlock(&xbee_dev->mutex);
+#else
+	pthread_mutex_unlock(&xbee_dev->mutex);
+#endif
+
+	return 0;
+}
+
+static int
+xbee_device_remove_pendent_req(struct xbee_device *xbee_dev, _api_frame_t *api_frame)
+{
+	int index = 0;
+
+	if(xbee_dev == NULL)
+	{
+		printk(KERN_ERR "%s: xbee_dev NULL pointer\n", __func__);
+		BUG();
+	}
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: api_frame NULL pointer\n", __func__);
+		BUG();
+	}
+
+	pr_debug("%s(): removing pendent req\n", __func__);
+
+#ifdef __KERNEL__
+	if (mutex_lock_interruptible(&xbee_dev->mutex))
+		return -EINTR;
+#else
+	if(pthread_mutex_lock(&xbee_dev->mutex))
+		return -EINTR;
+#endif
+
+	index = _api_frame_should_wait_response(api_frame);
+	if(index)
+		temporary_frames_list[index] = NULL;
+
+#ifdef __KERNEL__
+	mutex_unlock(&xbee_dev->mutex);
+#else
+	pthread_mutex_unlock(&xbee_dev->mutex);
+#endif
+
+	return 0;
+}
+
+static int
+_api_frame_should_signal_pendent(_api_frame_t *api_frame);
+static void
+_api_frame_print(_api_frame_t *api_frame);
+
+static int
+xbee_device_signal_pendent_req(struct xbee_device *xbee_dev, _api_frame_t *api_frame_response)
+{
+	int index = 0;
+	_api_frame_t *api_frame_req = NULL;
+
+	if(xbee_dev == NULL)
+	{
+		printk(KERN_ERR "%s: xbee_dev NULL pointer\n", __func__);
+		BUG();
+	}
+	if(api_frame_response == NULL)
+	{
+		printk(KERN_ERR "%s: api_frame NULL pointer\n", __func__);
+		BUG();
+	}
+
+#ifdef __KERNEL__
+	if (mutex_lock_interruptible(&xbee_dev->mutex))
+		return -EINTR;
+#else
+	if(pthread_mutex_lock(&xbee_dev->mutex))
+		return -EINTR;
+#endif
+
+	index = _api_frame_should_signal_pendent(api_frame_response);
+	api_frame_req = temporary_frames_list[index];
+
+	if(api_frame_req != NULL)
+	{
+		pr_debug("%s(): api_frame found...\n", __func__);
+		_api_frame_print(api_frame_req);
+#ifndef __KERNEL__
+		pthread_mutex_lock(&api_frame_req->mutex);
+#endif
+		api_frame_req->response = api_frame_response;
+#ifndef __KERNEL__
+		pthread_cond_signal(&api_frame_req->complete);
+		pthread_mutex_unlock(&api_frame_req->mutex);
+#else
+		complete(&api_frame_req->complete);
+#endif
+	}
+	else
+	{
+		printk(KERN_DEBUG "%s: api_frame NOT found: %d\n", __func__,index);
+	}
+
+	temporary_frames_list[index] = NULL;
+
+#ifdef __KERNEL__
+	mutex_unlock(&xbee_dev->mutex);
+#else
+	pthread_mutex_unlock(&xbee_dev->mutex);
+#endif
+
+	return 0;
+}
+
+/*
+ * Debug helpers
+ */
+
+#ifdef DEBUG
+static const char *
+xbee_recv_state_str(int recv_state)
+{
+	switch(recv_state)
+	{
+	case RECV_STATE_WAIT_START_DELIM:
+		return "RECV_STATE_WaitStartDelim";
+		break;
+	case RECV_STATE_WAIT_MSB:
+		return "RECV_STATE_WaitMSB";
+		break;
+	case RECV_STATE_WAIT_LSB:
+		return "RECV_STATE_WaitLSB";
+		break;
+	case RECV_STATE_WAIT_DATA:
+		return "RECV_STATE_WaitData";
+		break;
+	case RECV_STATE_WAIT_CHECKSUM:
+		return "RECV_STATE_WaitCheckSum";
+		break;
+	default:
+		return "RECV_STATE_Unknown";
+		break;
+	}
+	return "RECV_STATE_Unknown";
+}
+#endif /* DEBUG */
+
+static int
+at_command_get_parameter_len(_api_frame_t *api_frame)
+{
+	int	at_parameter_len = 0;
+	if(!api_frame)
+		return 0;
+	switch(api_frame->api_id){
+	case FRAME_TYPE_AT_CMD:
+		at_parameter_len = api_frame->len-4;
+		break;
+	case FRAME_TYPE_AT_CMD_QUEUE:
+		at_parameter_len = api_frame->len-4;
+		break;
+	case FRAME_TYPE_REMOTE_AT_CMD_REQ:
+		at_parameter_len = api_frame->len-15;
+		break;
+	case FRAME_TYPE_AT_CMD_RESP:
+		at_parameter_len = api_frame->len-5;
+		break;
+	case FRAME_TYPE_REMOTE_CMD_RESP:
+		at_parameter_len = api_frame->len-15;
+		break;
+	default:
+		return 0;
+	}
+	return at_parameter_len;
+}
+
+#ifdef DEBUG
+static const char *
+at_command_get_parameter_str(_api_frame_t *api_frame,char *str_aux)
+{
+	uint8_t *at_data = NULL;
+	int wrote_bytes = 0;
+	int	at_parameter_len = 0;
+	int i = 0;
+	if(!api_frame)
+		return "";
+	at_parameter_len = at_command_get_parameter_len(api_frame);
+	switch(api_frame->api_id){
+	case FRAME_TYPE_AT_CMD:
+		at_data = (uint8_t *) api_frame->api_data->at_cmd.parameter_value;
+		break;
+	case FRAME_TYPE_AT_CMD_QUEUE:
+		at_data = (uint8_t *) api_frame->api_data->at_cmd_queue.parameter_value;
+		break;
+	case FRAME_TYPE_REMOTE_AT_CMD_REQ:
+		at_data = (uint8_t *) api_frame->api_data->remote_at_cmd_req.parameter_value;
+		break;
+	case FRAME_TYPE_AT_CMD_RESP:
+		at_data = (uint8_t *) api_frame->api_data->at_cmd_resp.cmd_data;
+		break;
+	case FRAME_TYPE_REMOTE_CMD_RESP:
+		at_data = (uint8_t *) api_frame->api_data->remote_cmd_resp.cmd_data;
+		break;
+	default:
+		return "";
+	}
+	for(i=0;i<at_parameter_len;i++)
+	{
+		wrote_bytes += sprintf(str_aux+wrote_bytes,"%02X",at_data[i]);
+	}
+	str_aux[wrote_bytes] = '\0';
+	return str_aux;
+}
+#endif /* DEBUG */
+
+static const char *
+eui64_address_to_str(uint8_t addr[XBEE_ADDR_LEN],char eui64_addr_str[24])
+{
+	int i = 0;
+	int wrote_bytes = 0;
+	for(i=0;i<XBEE_ADDR_LEN;i++)
+	{
+		if(i)
+			wrote_bytes += sprintf(eui64_addr_str+wrote_bytes,":");
+		wrote_bytes += sprintf(eui64_addr_str+wrote_bytes,"%02X",addr[i]);
+	}
+	eui64_addr_str[wrote_bytes] = '\0';
+	return eui64_addr_str;
+}
+
+
+/*
+ * API Frame helpers
+ */
+
+static void _api_frame_free(_api_frame_t *api_frame);
+
+static _api_frame_t *
+_api_frame_alloc(size_t frame_len, size_t data_len)
+{
+	void *api_data = NULL;
+	_api_frame_t *api_frame = NULL;
+#ifdef __KERNEL__
+	api_frame = kzalloc(sizeof(_api_frame_t),GFP_KERNEL);
+#else
+	api_frame = calloc(1,sizeof(_api_frame_t));
+#endif
+	if(!api_frame)
+	{
+		printk(KERN_ERR "%s(): unable to allocate memory to api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->len = frame_len;
+#ifdef __KERNEL__
+	api_data = kzalloc(data_len,GFP_KERNEL);
+#else
+	api_data = calloc(data_len,sizeof(uint8_t));
+#endif
+	if(!api_data)
+	{
+		printk(KERN_ERR "%s(): unable to allocate memory to api_data\n", __func__);
+		_api_frame_free(api_frame);
+		api_frame = NULL;
+		BUG();
+	}
+
+	api_frame->api_data = (union api_cmd_data_union*) api_data;
+
+#ifdef __KERNEL__
+	mutex_init(&api_frame->mutex);
+#else
+	pthread_mutex_init(&api_frame->mutex,NULL);
+#endif
+
+#ifdef __KERNEL__
+	init_completion(&api_frame->complete);
+#else
+	pthread_cond_init(&api_frame->complete,NULL);
+#endif
+
+	api_frame->response = NULL;
+
+	return api_frame;
+}
+
+static uint8_t *
+_api_frame_to_raw(_api_frame_t *api_frame, uint16_t *p_len)
+{
+	uint8_t *raw_data = NULL;
+	uint8_t frame_sum = 0;
+	int raw_offset = 0;
+	int i = 0;
+	uint16_t raw_data_len = 1 /* start delim */ + 2 /* 16 bit length */;
+	if(!api_frame)
+	{
+		printk(KERN_ERR "%s(): invalid frame\n", __func__);
+		BUG();
+	}
+	if(!p_len)
+	{
+		printk(KERN_ERR "%s(): invalid len pointer\n", __func__);
+		BUG();
+	}
+
+	/* Compute buffer length */
+	switch(api_frame->api_id)
+	{
+	// Requests
+	case FRAME_TYPE_AT_CMD:
+		raw_data_len += 1 /* frame type */ + 1 /* frame id */ + 2 /* at command */;
+		raw_data_len += api_frame->api_data->at_cmd.parameter_value_len;
+		break;
+	case FRAME_TYPE_AT_CMD_QUEUE:
+		raw_data_len += 1 /* frame type */ + 1 /* frame id */ + 2 /* at command */;
+		raw_data_len += api_frame->api_data->at_cmd_queue.parameter_value_len;
+		break;
+	case FRAME_TYPE_TRANSMIT_REQ:
+		raw_data_len += 1 /* frame type */ + 1 /* frame id */;
+		raw_data_len += 8 /* dst addr */ + 2 /* reserved */;
+		raw_data_len += 1 /* bcast radius */ + 1 /* options */;
+		raw_data_len += api_frame->api_data->transmit_req.payload_len;
+		break;
+	case FRAME_TYPE_RAW_TRANSMIT_REQ:
+		raw_data_len += 1 /* frame type */ + 1 /* frame id */;
+		raw_data_len += api_frame->api_data->raw_packet.payload_len;
+		break;
+	case FRAME_TYPE_EXPLICIT_ADDR_CMD:
+		raw_data_len += 1 /* frame type */ + 1 /* frame id */;
+		raw_data_len += 8 /* dst addr */ + 2 /* reserved */;
+		raw_data_len += 1 /* src endpoint */ + 1 /* dst endpoint */;
+		raw_data_len += 2 /* clusterID */ + 2 /* profile ID*/;
+		raw_data_len += 1 /* bcast radius */ + 1 /* options */;
+		raw_data_len += api_frame->api_data->explitcit_addr_cmd.payload_len;
+		break;
+	case FRAME_TYPE_REMOTE_AT_CMD_REQ:
+		raw_data_len += 1 /* frame type */ + 1 /* frame id */;
+		raw_data_len += 8 /* dst addr */ + 2 /* reserved */;
+		raw_data_len += 1 /* remote command options */ + 2 /* at command */;
+		raw_data_len += api_frame->api_data->remote_at_cmd_req.parameter_value_len;
+		break;
+
+	// Responses
+	case FRAME_TYPE_AT_CMD_RESP:
+		break;
+	case FRAME_TYPE_MODEM_STATUS:
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS1:
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS2:
+		break;
+	case FRAME_TYPE_RAW_TRANSMIT_STATUS:
+		break;
+	case FRAME_TYPE_RECEIVE_PACKET:
+		break;
+	case FRAME_TYPE_EXPLICIT_RX_INDICATOR:
+		break;
+	case FRAME_TYPE_NODE_ID_INDICATOR:
+		break;
+	case FRAME_TYPE_REMOTE_CMD_RESP:
+		break;
+	default:
+		printk(KERN_WARNING "%s(): Unknown Type (0x%02X)\n", __func__,api_frame->api_id);
+		break;
+		return NULL;
+	}
+	raw_data_len += 1 /* checksum */;
+
+#ifdef __KERNEL__
+	raw_data = kzalloc(raw_data_len*sizeof(uint8_t),GFP_KERNEL);
+#else
+	raw_data = calloc(raw_data_len,sizeof(uint8_t));
+#endif
+	if(!raw_data)
+	{
+		printk(KERN_ERR "%s(): unable to allocate memory\n", __func__);
+		return NULL;
+	}
+
+	*p_len = raw_data_len;
+
+	raw_data[raw_offset++] = XBEE_START_DELIM;
+	raw_data[raw_offset++] = (raw_data_len-4) >> 8 & 0xFF;
+	raw_data[raw_offset++] = (raw_data_len-4) & 0xFF;
+
+	/* Fill buffer */
+	switch(api_frame->api_id)
+	{
+	// Requests
+	case FRAME_TYPE_AT_CMD:
+		raw_data[raw_offset] = api_frame->api_data->at_cmd.api_id;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->at_cmd.frame_id;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->at_cmd.at_command[0];
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->at_cmd.at_command[1];
+		frame_sum += raw_data[raw_offset++];
+		for(i=0;i<api_frame->api_data->at_cmd.parameter_value_len;i++)
+		{
+			raw_data[raw_offset] = api_frame->api_data->at_cmd.parameter_value[i];
+			frame_sum += raw_data[raw_offset++];
+		}
+		break;
+	case FRAME_TYPE_AT_CMD_QUEUE:
+		raw_data[raw_offset] = api_frame->api_data->at_cmd_queue.api_id;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->at_cmd_queue.frame_id;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->at_cmd_queue.at_command[0];
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->at_cmd_queue.at_command[1];
+		frame_sum += raw_data[raw_offset++];
+		for(i=0;i<api_frame->api_data->at_cmd_queue.parameter_value_len;i++)
+		{
+			raw_data[raw_offset] = api_frame->api_data->at_cmd_queue.parameter_value[i];
+			frame_sum += raw_data[raw_offset++];
+		}
+		break;
+	case FRAME_TYPE_TRANSMIT_REQ:
+		raw_data[raw_offset] = api_frame->api_data->transmit_req.api_id;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->transmit_req.frame_id;
+		frame_sum += raw_data[raw_offset++];
+		for(i=0;i<XBEE_ADDR_LEN;i++)
+		{
+			raw_data[raw_offset] = api_frame->api_data->transmit_req.dst_addr[i];
+			frame_sum += raw_data[raw_offset++];
+		}
+		raw_data[raw_offset] = api_frame->api_data->transmit_req.reserved >> 8 & 0xFF;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->transmit_req.reserved & 0xFF;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->transmit_req.brd_radius;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->transmit_req.options;
+		frame_sum += raw_data[raw_offset++];
+
+		for(i=0;i<api_frame->api_data->transmit_req.payload_len;i++)
+		{
+			raw_data[raw_offset] = api_frame->api_data->transmit_req.payload[i];
+			frame_sum += raw_data[raw_offset++];
+		}
+		break;
+	case FRAME_TYPE_RAW_TRANSMIT_REQ:
+		raw_data[raw_offset] = api_frame->api_data->raw_packet.api_id;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->raw_packet.frame_id;
+		frame_sum += raw_data[raw_offset++];
+		for(i=0;i<api_frame->api_data->raw_packet.payload_len;i++)
+		{
+			raw_data[raw_offset] = api_frame->api_data->raw_packet.payload[i];
+			frame_sum += raw_data[raw_offset++];
+		}
+		break;
+	case FRAME_TYPE_EXPLICIT_ADDR_CMD:
+		break;
+	case FRAME_TYPE_REMOTE_AT_CMD_REQ:
+		raw_data[raw_offset] = api_frame->api_data->remote_at_cmd_req.api_id;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->remote_at_cmd_req.frame_id;
+		frame_sum += raw_data[raw_offset++];
+		for(i=0;i<XBEE_ADDR_LEN;i++)
+		{
+			raw_data[raw_offset] = api_frame->api_data->remote_at_cmd_req.dst_addr[i];
+			frame_sum += raw_data[raw_offset++];
+		}
+		raw_data[raw_offset] = api_frame->api_data->remote_at_cmd_req.reserved >> 8 & 0xFF;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->remote_at_cmd_req.reserved & 0xFF;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->remote_at_cmd_req.remote_options;
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->remote_at_cmd_req.at_command[0];
+		frame_sum += raw_data[raw_offset++];
+		raw_data[raw_offset] = api_frame->api_data->remote_at_cmd_req.at_command[1];
+		frame_sum += raw_data[raw_offset++];
+		for(i=0;i<api_frame->api_data->remote_at_cmd_req.parameter_value_len;i++)
+		{
+			raw_data[raw_offset] = api_frame->api_data->remote_at_cmd_req.parameter_value[i];
+			frame_sum += raw_data[raw_offset++];
+		}
+		break;
+
+	// Responses
+	case FRAME_TYPE_AT_CMD_RESP:
+		break;
+	case FRAME_TYPE_MODEM_STATUS:
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS1:
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS2:
+		break;
+	case FRAME_TYPE_RAW_TRANSMIT_STATUS:
+		break;
+	case FRAME_TYPE_RECEIVE_PACKET:
+		break;
+	case FRAME_TYPE_EXPLICIT_RX_INDICATOR:
+		break;
+	case FRAME_TYPE_NODE_ID_INDICATOR:
+		break;
+	case FRAME_TYPE_REMOTE_CMD_RESP:
+		break;
+	default:
+		printk(KERN_WARNING "%s(): Unknown Type (0x%02X)\n", __func__,api_frame->api_id);
+#ifdef __KERNEL__
+		kfree(raw_data);
+#else
+		free(raw_data);
+#endif
+		*p_len = 0;
+		break;
+		return NULL;
+	}
+	raw_data[raw_offset++] = 0xFF - frame_sum;
+
+	return raw_data;
+}
+
+static int
+_api_frame_should_wait_response(_api_frame_t *api_frame)
+{
+	switch(api_frame->api_id)
+	{
+	// Requests
+	case FRAME_TYPE_AT_CMD:
+		if(api_frame->api_data->at_cmd.frame_id)
+			return api_frame->api_data->at_cmd.frame_id;
+		break;
+	case FRAME_TYPE_AT_CMD_QUEUE:
+		if(api_frame->api_data->at_cmd_queue.frame_id)
+			return api_frame->api_data->at_cmd_queue.frame_id;
+		break;
+	case FRAME_TYPE_TRANSMIT_REQ:
+		if(api_frame->api_data->transmit_req.frame_id)
+			return api_frame->api_data->transmit_req.frame_id;
+		break;
+	case FRAME_TYPE_RAW_TRANSMIT_REQ:
+		if(api_frame->api_data->raw_packet.frame_id)
+			return api_frame->api_data->raw_packet.frame_id;
+		break;
+	case FRAME_TYPE_EXPLICIT_ADDR_CMD:
+		if(api_frame->api_data->explitcit_addr_cmd.frame_id)
+			return api_frame->api_data->explitcit_addr_cmd.frame_id;
+		break;
+	case FRAME_TYPE_REMOTE_AT_CMD_REQ:
+		if(api_frame->api_data->remote_at_cmd_req.frame_id)
+			return api_frame->api_data->remote_at_cmd_req.frame_id;
+		break;
+
+	// Responses
+	case FRAME_TYPE_AT_CMD_RESP:
+		break;
+	case FRAME_TYPE_MODEM_STATUS:
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS1:
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS2:
+		break;
+	case FRAME_TYPE_RAW_TRANSMIT_STATUS:
+		break;
+	case FRAME_TYPE_RECEIVE_PACKET:
+		break;
+	case FRAME_TYPE_EXPLICIT_RX_INDICATOR:
+		break;
+	case FRAME_TYPE_NODE_ID_INDICATOR:
+		break;
+	case FRAME_TYPE_REMOTE_CMD_RESP:
+		break;
+	default:
+		printk(KERN_WARNING "%s(): Unknown Type (0x%02X)\n", __func__,api_frame->api_id);
+		break;
+		return 0;
+	}
+	return 0;
+}
+
+static int
+_api_frame_should_signal_pendent(_api_frame_t *api_frame)
+{
+	switch(api_frame->api_id)
+	{
+	// Requests
+	case FRAME_TYPE_AT_CMD:
+		break;
+	case FRAME_TYPE_AT_CMD_QUEUE:
+		break;
+	case FRAME_TYPE_TRANSMIT_REQ:
+		break;
+	case FRAME_TYPE_RAW_TRANSMIT_REQ:
+		break;
+	case FRAME_TYPE_EXPLICIT_ADDR_CMD:
+		break;
+	case FRAME_TYPE_REMOTE_AT_CMD_REQ:
+		break;
+
+	// Responses
+	case FRAME_TYPE_AT_CMD_RESP:
+		if(api_frame->api_data->at_cmd_resp.frame_id)
+			return api_frame->api_data->at_cmd_resp.frame_id;
+		break;
+	case FRAME_TYPE_MODEM_STATUS:
+		return 0;
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS1:
+		if(api_frame->api_data->transmit_status.frame_id)
+			return api_frame->api_data->transmit_status.frame_id;
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS2:
+		if(api_frame->api_data->transmit_status2.frame_id)
+			return api_frame->api_data->transmit_status2.frame_id;
+		break;
+	case FRAME_TYPE_RAW_TRANSMIT_STATUS:
+		if(api_frame->api_data->raw_transmit_status.frame_id)
+			return api_frame->api_data->raw_transmit_status.frame_id;
+		break;
+	case FRAME_TYPE_RECEIVE_PACKET:
+		return 0;
+		break;
+	case FRAME_TYPE_EXPLICIT_RX_INDICATOR:
+		return 0;
+		break;
+	case FRAME_TYPE_NODE_ID_INDICATOR:
+		return 0;
+		break;
+	case FRAME_TYPE_REMOTE_CMD_RESP:
+		if(api_frame->api_data->remote_cmd_resp.frame_id)
+			return api_frame->api_data->remote_cmd_resp.frame_id;
+		break;
+	default:
+		printk(KERN_WARNING "%s(): Unknown Type (0x%02X)\n", __func__,api_frame->api_id);
+		break;
+		return 0;
+	}
+	return 0;
+}
+
+static _api_frame_t *
+_api_frame_parse(uint16_t frame_len, uint8_t *raw_data, uint8_t checksum)
+{
+	size_t api_data_size = 0;
+	_api_frame_t *api_frame = NULL;
+	int i = 0;
+	int ni_string_len = 0;
+#ifdef __KERNEL__
+	api_frame = kzalloc(sizeof(_api_frame_t),GFP_KERNEL);
+#else
+	api_frame = calloc(1,sizeof(_api_frame_t));
+#endif
+	if(!api_frame)
+	{
+		printk(KERN_ERR "%s(): unable to allocate memory\n", __func__);
+		_api_frame_free(api_frame);
+		BUG();
+	}
+
+	api_frame->len = frame_len;
+	api_frame->raw_data = raw_data;
+	api_frame->api_id = *(api_frame->raw_data);
+	api_frame->checksum = checksum;
+	api_frame->response = NULL;
+
+	switch(api_frame->api_id)
+	{
+	// Requests
+	case FRAME_TYPE_AT_CMD:
+		api_data_size = sizeof(api_frame_at_cmd_t);
+		break;
+	case FRAME_TYPE_TRANSMIT_REQ:
+		api_data_size = sizeof(api_frame_transmit_req_t);
+		break;
+
+	// Responses
+	case FRAME_TYPE_AT_CMD_RESP:
+		api_data_size = sizeof(api_frame_at_cmd_resp_t);
+		break;
+	case FRAME_TYPE_MODEM_STATUS:
+		api_data_size = sizeof(api_frame_modem_status_t);
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS1:
+		api_data_size = sizeof(api_frame_transmit_status1_t);
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS2:
+		api_data_size = sizeof(api_frame_transmit_status2_t);
+		break;
+	case FRAME_TYPE_RAW_TRANSMIT_STATUS:
+		api_data_size = sizeof(api_frame_raw_transmit_status_t);
+		break;
+	case FRAME_TYPE_RECEIVE_PACKET:
+		api_data_size = sizeof(api_frame_receive_packet_t);
+		break;
+	case FRAME_TYPE_EXPLICIT_RX_INDICATOR:
+		api_data_size = sizeof(api_frame_explicit_rx_indicator_t);
+		break;
+	case FRAME_TYPE_NODE_ID_INDICATOR:
+		api_data_size = sizeof(api_frame_node_id_indicator_t);
+		break;
+	case FRAME_TYPE_REMOTE_CMD_RESP:
+		api_data_size = sizeof(api_frame_remote_cmd_resp_t);
+		break;
+
+	// RAW
+	case FRAME_TYPE_RAW_TRANSMIT_REQ:
+		api_data_size = sizeof(api_frame_raw_packet_t);
+		break;
+
+	default:
+		printk(KERN_ERR "%s(): unknown or unimplemented parsing: Type: 0x%02X\n", __func__,api_frame->api_id);
+		print_hex_dump_bytes("xbee_net_rx(): ", DUMP_PREFIX_NONE, raw_data,frame_len);
+		api_frame->raw_data = NULL;
+		_api_frame_free(api_frame);
+		return NULL;
+	}
+
+#ifdef __KERNEL__
+	api_frame->api_data = kzalloc(api_data_size,GFP_KERNEL);
+#else
+	api_frame->api_data = calloc(api_data_size,sizeof(uint8_t));
+#endif
+	if(!api_frame->api_data)
+	{
+		printk(KERN_ERR "%s(): unable to allocate memory\n", __func__);
+		api_frame->raw_data = NULL;
+		_api_frame_free(api_frame);
+		BUG();
+	}
+	switch(api_frame->api_id)
+	{
+	case FRAME_TYPE_AT_CMD:
+		api_frame->api_data->at_cmd.api_id = *(api_frame->raw_data);
+		api_frame->api_data->at_cmd.frame_id = *(api_frame->raw_data+1);
+		api_frame->api_data->at_cmd.at_command[0] = *(api_frame->raw_data+2);
+		api_frame->api_data->at_cmd.at_command[1] = *(api_frame->raw_data+3);
+		api_frame->api_data->at_cmd.parameter_value_len = at_command_get_parameter_len(api_frame);
+		for(i=0;i<api_frame->api_data->at_cmd.parameter_value_len;i++)
+		{
+			api_frame->api_data->at_cmd.parameter_value[i] = *(api_frame->raw_data+4+i);
+		}
+		break;
+	case FRAME_TYPE_TRANSMIT_REQ:
+		api_frame->api_data->transmit_req.api_id = *(api_frame->raw_data);
+		api_frame->api_data->transmit_req.frame_id = *(api_frame->raw_data+1);
+		memcpy(api_frame->api_data->transmit_req.dst_addr, api_frame->raw_data+2, XBEE_ADDR_LEN);
+		api_frame->api_data->transmit_req.reserved = ((*(api_frame->raw_data+10))<<8)+*(api_frame->raw_data+11);
+		api_frame->api_data->transmit_req.brd_radius = *(api_frame->raw_data+12);
+		api_frame->api_data->transmit_req.options = *(api_frame->raw_data+13);
+		api_frame->api_data->transmit_req.payload = api_frame->raw_data+14;
+		api_frame->api_data->transmit_req.payload_len = api_frame->len-14;
+		break;
+
+	// Responses
+	case FRAME_TYPE_AT_CMD_RESP:
+		api_frame->api_data->at_cmd_resp.api_id = *(api_frame->raw_data);
+		api_frame->api_data->at_cmd_resp.frame_id = *(api_frame->raw_data+1);
+		api_frame->api_data->at_cmd_resp.at_command[0] = *(api_frame->raw_data+2);
+		api_frame->api_data->at_cmd_resp.at_command[1] = *(api_frame->raw_data+3);
+		api_frame->api_data->at_cmd_resp.cmd_status = *(api_frame->raw_data+4);
+		api_frame->api_data->at_cmd_resp.cmd_data_len = at_command_get_parameter_len(api_frame);
+		for(i=0;i<api_frame->api_data->at_cmd_resp.cmd_data_len;i++)
+		{
+			api_frame->api_data->at_cmd_resp.cmd_data[i] = *(api_frame->raw_data+5+i);
+		}
+		break;
+	case FRAME_TYPE_MODEM_STATUS:
+		api_frame->api_data->modem_status.api_id = *(api_frame->raw_data);
+		api_frame->api_data->modem_status.status = *(api_frame->raw_data+1);
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS1:
+		api_frame->api_data->transmit_status.api_id = *(api_frame->raw_data);
+		api_frame->api_data->transmit_status.frame_id = *(api_frame->raw_data+1);
+		api_frame->api_data->transmit_status.reserved = ((*(api_frame->raw_data+2))<<8)+*(api_frame->raw_data+3);
+		api_frame->api_data->transmit_status.transmit_retry_count = *(api_frame->raw_data+4);
+		api_frame->api_data->transmit_status.delivery_status = *(api_frame->raw_data+5);
+		api_frame->api_data->transmit_status.discovery_status = *(api_frame->raw_data+6);
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS2:
+		api_frame->api_data->transmit_status2.api_id = *(api_frame->raw_data);
+		api_frame->api_data->transmit_status2.frame_id = *(api_frame->raw_data+1);
+		api_frame->api_data->transmit_status2.delivery_status = *(api_frame->raw_data+2);
+		break;
+	case FRAME_TYPE_RECEIVE_PACKET:
+		api_frame->api_data->receive_packet.api_id = *(api_frame->raw_data);
+		memcpy(api_frame->api_data->receive_packet.src_addr, api_frame->raw_data+1, XBEE_ADDR_LEN);
+		api_frame->api_data->receive_packet.reserved = ((*(api_frame->raw_data+9))<<8)+*(api_frame->raw_data+10);
+		api_frame->api_data->receive_packet.options = *(api_frame->raw_data+11);
+		//api_frame->api_data->receive_packet.split_header = *(api_frame->raw_data+12);
+		api_frame->api_data->receive_packet.payload = api_frame->raw_data+12;
+		api_frame->api_data->receive_packet.payload_len = api_frame->len-12;
+		break;
+	case FRAME_TYPE_EXPLICIT_RX_INDICATOR:
+		api_frame->api_data->explicit_rx_indicator.api_id = *(api_frame->raw_data);
+		memcpy(api_frame->api_data->explicit_rx_indicator.src_addr, api_frame->raw_data+1, XBEE_ADDR_LEN);
+		api_frame->api_data->explicit_rx_indicator.reserved = ((*(api_frame->raw_data+9))<<8)+*(api_frame->raw_data+10);
+		api_frame->api_data->explicit_rx_indicator.src_endpoint = *(api_frame->raw_data+11);
+		api_frame->api_data->explicit_rx_indicator.dst_endpoint = *(api_frame->raw_data+12);
+		api_frame->api_data->explicit_rx_indicator.cluster_id = ((*(api_frame->raw_data+13))<<8)+*(api_frame->raw_data+14);
+		api_frame->api_data->explicit_rx_indicator.profile_id = ((*(api_frame->raw_data+15))<<8)+*(api_frame->raw_data+16);
+		api_frame->api_data->explicit_rx_indicator.options = *(api_frame->raw_data+17);
+		api_frame->api_data->explicit_rx_indicator.payload = api_frame->raw_data+18;
+		api_frame->api_data->explicit_rx_indicator.payload_len = api_frame->len-18;
+		break;
+	case FRAME_TYPE_NODE_ID_INDICATOR:
+		api_frame->api_data->node_id_indicator.api_id = *(api_frame->raw_data);
+		memcpy(api_frame->api_data->node_id_indicator.sender_addr, api_frame->raw_data+1, XBEE_ADDR_LEN);
+		api_frame->api_data->node_id_indicator.sender_short_addr = ((*(api_frame->raw_data+9))<<8)+*(api_frame->raw_data+10);
+		api_frame->api_data->node_id_indicator.options = *(api_frame->raw_data+11);
+		api_frame->api_data->node_id_indicator.src_short_addr = ((*(api_frame->raw_data+12))<<8)+*(api_frame->raw_data+13);
+		memcpy(api_frame->api_data->node_id_indicator.src_addr, api_frame->raw_data+14, XBEE_ADDR_LEN);
+		api_frame->api_data->node_id_indicator.ni_string = api_frame->raw_data+22;
+		ni_string_len = strlen((char*)api_frame->api_data->node_id_indicator.ni_string);
+		api_frame->api_data->node_id_indicator.parent_short_addr = ((*(api_frame->raw_data+22+ni_string_len+1))<<8)+*(api_frame->raw_data+23+ni_string_len+1);
+		break;
+	case FRAME_TYPE_REMOTE_CMD_RESP:
+		api_frame->api_data->remote_cmd_resp.api_id = *(api_frame->raw_data);
+		api_frame->api_data->remote_cmd_resp.frame_id = *(api_frame->raw_data+1);
+		memcpy(api_frame->api_data->remote_cmd_resp.src_addr, api_frame->raw_data+2, XBEE_ADDR_LEN);
+		api_frame->api_data->remote_cmd_resp.reserved = ((*(api_frame->raw_data+10))<<8)+*(api_frame->raw_data+11);
+		api_frame->api_data->remote_cmd_resp.at_command[0] = *(api_frame->raw_data+12);
+		api_frame->api_data->remote_cmd_resp.at_command[1] = *(api_frame->raw_data+13);
+		api_frame->api_data->remote_cmd_resp.cmd_status = *(api_frame->raw_data+14);
+		api_frame->api_data->remote_cmd_resp.cmd_data_len = at_command_get_parameter_len(api_frame);
+		for(i=0;i<api_frame->api_data->remote_cmd_resp.cmd_data_len;i++)
+		{
+			api_frame->api_data->remote_cmd_resp.cmd_data[i] = *(api_frame->raw_data+15+i);
+		}
+		break;
+
+	// RAW packet
+	// case FRAME_TYPE_RAW_RECEIVE:
+	case FRAME_TYPE_RAW_TRANSMIT_REQ:
+		api_frame->api_data->raw_packet.api_id = *(api_frame->raw_data);
+		api_frame->api_data->raw_packet.frame_id = *(api_frame->raw_data+1); // this is the LQI on RAW received
+		api_frame->api_data->raw_packet.payload = api_frame->raw_data+2;
+		api_frame->api_data->raw_packet.payload_len = api_frame->len-2;
+		break;
+
+	case FRAME_TYPE_RAW_TRANSMIT_STATUS:
+		api_frame->api_data->raw_transmit_status.api_id = *(api_frame->raw_data);
+		api_frame->api_data->raw_transmit_status.frame_id = *(api_frame->raw_data+1);
+		api_frame->api_data->raw_transmit_status.retries = *(api_frame->raw_data+2);
+		api_frame->api_data->raw_transmit_status.delivery_status = *(api_frame->raw_data+3);
+		break;
+
+	default:
+		printk(KERN_ERR "%s(): unknown or unimplemented parsing #2: Type: 0x%02X\n", __func__,api_frame->api_id);
+		api_frame->raw_data = NULL;
+		_api_frame_free(api_frame);
+		return NULL;
+	}
+
+#ifdef __KERNEL__
+	mutex_init(&api_frame->mutex);
+#else
+	pthread_mutex_init(&api_frame->mutex,NULL);
+	pthread_cond_init(&api_frame->complete,NULL);
+#endif
+
+#ifndef __KERNEL__
+#ifdef	DEBUG
+	printk(KERN_DEBUG "%s(): new frame %"PRIu16" bytes length: cmdID: 0x%02X\n",
+			__func__,api_frame->len,api_frame->api_id);
+#endif
+#endif
+
+	return api_frame;
+}
+
+static void
+_api_frame_free(_api_frame_t *api_frame)
+{
+	if(!api_frame)
+	{
+		printk(KERN_ERR "%s: api frame NULL pointer\n", __func__);
+		BUG();
+	}
+
+	if(api_frame->response)
+	{
+		_api_frame_free(api_frame->response);
+	}
+
+	if(api_frame->api_data)
+	{
+#ifdef __KERNEL__
+		kfree(api_frame->api_data);
+#else
+		free(api_frame->api_data);
+#endif
+		api_frame->api_data = NULL;
+	}
+	if(api_frame->raw_data)
+	{
+#ifdef __KERNEL__
+		kfree(api_frame->raw_data);
+#else
+		free(api_frame->raw_data);
+#endif
+		api_frame->raw_data = NULL;
+	}
+
+#ifndef __KERNEL__
+	pthread_mutex_destroy(&api_frame->mutex);
+#endif
+
+#ifndef __KERNEL__
+	pthread_cond_destroy(&api_frame->complete);
+#endif
+
+#ifdef __KERNEL__
+	kfree(api_frame);
+#else
+	free(api_frame);
+#endif
+	api_frame = NULL;
+}
+
+static void
+_api_frame_print(_api_frame_t *api_frame)
+{
+#ifdef DEBUG
+	char str_aux[20] = {};
+	//123456789012345678901234
+	//AA:BB:CC:DD:EE:FF:11:22
+	char eui64_addr_str[24] = {};
+	int i = 0;
+
+	if(!api_frame)
+	{
+		printk(KERN_DEBUG "%s: api frame NULL pointer\n", __func__);
+		return;
+	}
+	printk(KERN_DEBUG "%s(): ______________________________________________________\n", __func__);
+	switch(api_frame->api_id)
+	{
+	case FRAME_TYPE_AT_CMD:
+		printk(KERN_DEBUG "%s(): Type: AT Command\n", __func__);
+		printk(KERN_DEBUG "%s(): FrameID: %d\n", __func__,api_frame->api_data->at_cmd.frame_id);
+		printk(KERN_DEBUG "%s(): Command: %c%c\n", __func__,api_frame->api_data->at_cmd.at_command[0],api_frame->api_data->at_cmd.at_command[1]);
+		printk(KERN_DEBUG "%s(): Parameter: %s\n", __func__,at_command_get_parameter_str(api_frame,str_aux));
+		break;
+	case FRAME_TYPE_AT_CMD_QUEUE:
+		printk(KERN_DEBUG "%s(): AT Command Queue Type\n", __func__);
+		printk(KERN_DEBUG "%s(): FrameID: %d\n", __func__,api_frame->api_data->at_cmd.frame_id);
+		printk(KERN_DEBUG "%s(): Command: %c%c\n", __func__,api_frame->api_data->at_cmd.at_command[0],api_frame->api_data->at_cmd.at_command[1]);
+		printk(KERN_DEBUG "%s(): Parameter: %s\n", __func__,at_command_get_parameter_str(api_frame,str_aux));
+		break;
+	case FRAME_TYPE_TRANSMIT_REQ:
+		printk(KERN_DEBUG "%s(): Type: Transmit Request\n", __func__);
+		printk(KERN_DEBUG "%s(): FrameID: %d\n", __func__,api_frame->api_data->transmit_req.frame_id);
+		printk(KERN_DEBUG "%s(): Dst Addr: %s\n", __func__,eui64_address_to_str(api_frame->api_data->transmit_req.dst_addr,eui64_addr_str));
+		printk(KERN_DEBUG "%s(): Reserved: %04X\n", __func__,api_frame->api_data->transmit_req.reserved);
+		printk(KERN_DEBUG "%s(): BroadcastRadius: %d\n", __func__,api_frame->api_data->transmit_req.brd_radius);
+		if(api_frame->api_data->transmit_req.options & 0x01)
+			printk(KERN_DEBUG "%s(): Ack Disabled\n", __func__);
+		if(api_frame->api_data->transmit_req.options & 0x02)
+			printk(KERN_DEBUG "%s(): Don't attempt route Discovery\n", __func__);
+		printk(KERN_DEBUG "%s(): Payload Lenght: %d\n", __func__,api_frame->api_data->transmit_req.payload_len);
+		printk(KERN_DEBUG "%s(): Payload: ", __func__);
+		for(i = 0;i<api_frame->api_data->transmit_req.payload_len;i++){
+			printk("%02X ",api_frame->api_data->transmit_req.payload[i]);
+		}
+		printk("\n");
+		break;
+	case FRAME_TYPE_RAW_PACKET:
+		printk(KERN_DEBUG "%s(): Type: Raw Packet\n", __func__);
+		printk(KERN_DEBUG "%s(): Payload Lenght: %d\n", __func__,api_frame->api_data->raw_packet.payload_len);
+		printk(KERN_DEBUG "%s(): Payload: ", __func__);
+		for(i = 0;i<api_frame->api_data->raw_packet.payload_len;i++){
+			printk("%02X ",api_frame->api_data->raw_packet.payload[i]);
+		}
+		printk("\n");
+		break;
+	case FRAME_TYPE_EXPLICIT_ADDR_CMD:
+		printk(KERN_DEBUG "%s(): Type: Explicit Addressing Command\n", __func__);
+		break;
+	case FRAME_TYPE_REMOTE_AT_CMD_REQ:
+		printk(KERN_DEBUG "%s(): Type: Remote AT Command Request\n", __func__);
+		break;
+	case FRAME_TYPE_AT_CMD_RESP:
+		printk(KERN_DEBUG "%s(): Type: AT Command Response\n", __func__);
+		printk(KERN_DEBUG "%s(): FrameID: %d\n", __func__,api_frame->api_data->at_cmd_resp.frame_id);
+		printk(KERN_DEBUG "%s(): Command: %c%c\n", __func__,api_frame->api_data->at_cmd_resp.at_command[0],api_frame->api_data->at_cmd_resp.at_command[1]);
+		switch(api_frame->api_data->at_cmd_resp.cmd_status)
+		{
+		case 0x00:
+			printk(KERN_DEBUG "%s(): Command Status: OK\n", __func__);
+			break;
+		case 0x01:
+			printk(KERN_DEBUG "%s(): Command Status: Error\n", __func__);
+			break;
+		case 0x02:
+			printk(KERN_DEBUG "%s(): Command Status: Invalid Command\n", __func__);
+			break;
+		case 0x03:
+			printk(KERN_DEBUG "%s(): Command Status: Invalid Parameter\n", __func__);
+			break;
+		default:
+			printk(KERN_DEBUG "%s(): Command Status: Unknown status 0x%02X\n", __func__,api_frame->api_data->at_cmd_resp.cmd_status);
+			break;
+		}
+		if(api_frame->api_data->at_cmd_resp.cmd_data_len)
+			printk(KERN_DEBUG "%s(): Parameter: %s\n", __func__,at_command_get_parameter_str(api_frame,str_aux));
+		break;
+	case FRAME_TYPE_MODEM_STATUS:
+		printk(KERN_DEBUG "%s(): Type: Modem Status\n", __func__);
+		switch(api_frame->api_data->modem_status.status)
+		{
+		case 0x00:
+			printk(KERN_DEBUG "%s(): Status: Hardware reset\n", __func__);
+			break;
+		case 0x01:
+			printk(KERN_DEBUG "%s(): Status: Watchdog time reset\n", __func__);
+			break;
+		case 0x0B:
+			printk(KERN_DEBUG "%s(): Status: Network Woke Up\n", __func__);
+			break;
+		case 0x0C:
+			printk(KERN_DEBUG "%s(): Status: Network Went To Sleep\n", __func__);
+			break;
+		default:
+			printk(KERN_DEBUG "%s(): Status: Unknown (0x%02X)\n", __func__,api_frame->api_data->modem_status.status);
+			break;
+		}
+		break;
+	case FRAME_TYPE_TRANSMIT_STATUS1:
+			printk(KERN_DEBUG "%s(): Type: Transmit Status\n", __func__);
+			printk(KERN_DEBUG "%s(): FrameID: %d\n", __func__,api_frame->api_data->transmit_status.frame_id);
+			printk(KERN_DEBUG "%s(): Reserved: %04X\n", __func__,api_frame->api_data->transmit_status.reserved);
+			printk(KERN_DEBUG "%s(): Transmit Retry Count: %d\n", __func__,api_frame->api_data->transmit_status.transmit_retry_count);
+			switch(api_frame->api_data->transmit_status.delivery_status)
+			{
+			case 0x00:
+				printk(KERN_DEBUG "%s(): Delivery Status: Success\n", __func__);
+				break;
+			case 0x01:
+				printk(KERN_DEBUG "%s(): Delivery Status: MAC ACK Failure\n", __func__);
+				break;
+			case 0x15:
+				printk(KERN_DEBUG "%s(): Delivery Status: Invalid destination endpoint\n", __func__);
+				break;
+			case 0x21:
+				printk(KERN_DEBUG "%s(): Delivery Status: Network ACK Failure\n", __func__);
+				break;
+			case 0x25:
+				printk(KERN_DEBUG "%s(): Delivery Status: Route Not Found\n", __func__);
+				break;
+			default:
+				printk(KERN_DEBUG "%s(): Delivery Status: Unknown (0x%02X)\n", __func__,api_frame->api_data->transmit_status.delivery_status);
+				break;
+			}
+			switch(api_frame->api_data->transmit_status.discovery_status)
+			{
+			case 0x00:
+				printk(KERN_DEBUG "%s(): Discovery Status: No Discovery Overhead\n", __func__);
+				break;
+			case 0x02:
+				printk(KERN_DEBUG "%s(): Discovery Status: Route Discovery\n", __func__);
+				break;
+			default:
+				printk(KERN_DEBUG "%s(): Discovery Status: Unknown (0x%02X)\n", __func__,api_frame->api_data->transmit_status.discovery_status);
+				break;
+			}
+			break;
+	case FRAME_TYPE_TRANSMIT_STATUS2:
+		printk(KERN_DEBUG "%s(): Type: Transmit Status 2\n", __func__);
+		printk(KERN_DEBUG "%s(): FrameID: %d\n", __func__,api_frame->api_data->transmit_status2.frame_id);
+		switch(api_frame->api_data->transmit_status2.delivery_status)
+		{
+		case 0x00:
+			printk(KERN_DEBUG "%s(): Success, no errors were detected on transmission.\n", __func__);
+			break;
+		case 0x01:
+			printk(KERN_DEBUG "%s(): An expected MAC acknowledgement never occurred.\n", __func__);
+			break;
+		case 0x02:
+			printk(KERN_DEBUG "%s(): CCA failure.\n", __func__);
+			break;
+		case 0x03:
+			printk(KERN_DEBUG "%s(): Transmission was purged because it was attempted before the stack was up.\n", __func__);
+			break;
+		case 0x04:
+			printk(KERN_DEBUG "%s(): Physical error occurred on the interface with the WiFi transceiver.\n", __func__);
+			break;
+		case 0x18:
+			printk(KERN_DEBUG "%s(): No Buffers.\n", __func__);
+			break;
+		case 0x21:
+			printk(KERN_DEBUG "%s(): An expected network acknowledgement never occurred.\n", __func__);
+			break;
+		case 0x22:
+			printk(KERN_DEBUG "%s(): Not joined to network.\n", __func__);
+			break;
+		case 0x23:
+			printk(KERN_DEBUG "%s(): Self-addressed.\n", __func__);
+			break;
+		case 0x24:
+			printk(KERN_DEBUG "%s(): Address not found.\n", __func__);
+			break;
+		case 0x25:
+			printk(KERN_DEBUG "%s(): Route not found.\n", __func__);
+			break;
+		case 0x26:
+			printk(KERN_DEBUG "%s(): Broadcast relay was not heard.\n", __func__);
+			break;
+		case 0x2B:
+			printk(KERN_DEBUG "%s(): Invalid Binding Table Index.\n", __func__);
+			break;
+		case 0x2C:
+			printk(KERN_DEBUG "%s(): Invalid Endpoint.\n", __func__);
+			break;
+		case 0x31:
+			printk(KERN_DEBUG "%s(): A software error occurred.\n", __func__);
+			break;
+		case 0x32:
+			printk(KERN_DEBUG "%s(): Resource Error.\n", __func__);
+			break;
+		case 0x74:
+			printk(KERN_DEBUG "%s(): Data payload too large.\n", __func__);
+			break;
+		case 0x76:
+			printk(KERN_DEBUG "%s(): Attempt to create a client socket failed.\n", __func__);
+			break;
+		case 0xBB:
+			printk(KERN_DEBUG "%s(): Key not authorized.\n", __func__);
+			break;
+		default:
+			printk(KERN_DEBUG "%s(): Delivery Status: Unknown (0x%02X)\n", __func__,api_frame->api_data->transmit_status2.delivery_status);
+			break;
+		}
+		break;
+	case FRAME_TYPE_RECEIVE_PACKET:
+		printk(KERN_DEBUG "%s(): Type: Receive Packet\n", __func__);
+		printk(KERN_DEBUG "%s(): Src Addr: %s\n", __func__,eui64_address_to_str(api_frame->api_data->receive_packet.src_addr,eui64_addr_str));
+		printk(KERN_DEBUG "%s(): Reserved: %04X\n", __func__,api_frame->api_data->receive_packet.reserved);
+		if(api_frame->api_data->receive_packet.options & 0x01)
+			printk(KERN_DEBUG "%s(): Packet Acknowleged\n", __func__);
+		if(api_frame->api_data->receive_packet.options & 0x02)
+			printk(KERN_DEBUG "%s(): Packet was broadcast packet\n", __func__);
+		printk(KERN_DEBUG "%s(): Payload Lenght: %d\n", __func__,api_frame->api_data->receive_packet.payload_len);
+		printk(KERN_DEBUG "%s(): Payload: ", __func__);
+		for(i = 0;i<api_frame->api_data->receive_packet.payload_len;i++){
+			printk("%02X ",api_frame->api_data->receive_packet.payload[i]);
+		}
+		printk("\n");
+
+		break;
+	case FRAME_TYPE_EXPLICIT_RX_INDICATOR:
+		printk(KERN_DEBUG "%s(): Type: Explitict RX Indicator\n", __func__);
+		printk(KERN_DEBUG "%s(): Src Addr: %s\n", __func__,eui64_address_to_str(api_frame->api_data->explicit_rx_indicator.src_addr,eui64_addr_str));
+		printk(KERN_DEBUG "%s(): Reserved: %04X\n", __func__,api_frame->api_data->explicit_rx_indicator.reserved);
+		printk(KERN_DEBUG "%s(): Src Endpoint: 0x%02X\n", __func__,api_frame->api_data->explicit_rx_indicator.src_endpoint);
+		printk(KERN_DEBUG "%s(): Dst Endpoint: 0x%02X\n", __func__,api_frame->api_data->explicit_rx_indicator.dst_endpoint);
+		printk(KERN_DEBUG "%s(): ClusterID: %04X\n", __func__,api_frame->api_data->explicit_rx_indicator.cluster_id);
+		printk(KERN_DEBUG "%s(): ProfileID: %04X\n", __func__,api_frame->api_data->explicit_rx_indicator.profile_id);
+		if(api_frame->api_data->explicit_rx_indicator.options & 0x01)
+			printk(KERN_DEBUG "%s(): Packet Acknowleged\n", __func__);
+		if(api_frame->api_data->explicit_rx_indicator.options & 0x02)
+			printk(KERN_DEBUG "%s(): Packet was broadcast packet\n", __func__);
+		printk(KERN_DEBUG "%s(): Payload Lenght: %d\n", __func__,api_frame->api_data->explicit_rx_indicator.payload_len);
+		printk(KERN_DEBUG "%s(): Payload: ", __func__);
+		for(i = 0;i<api_frame->api_data->explicit_rx_indicator.payload_len;i++){
+			printk("%02X ",api_frame->api_data->explicit_rx_indicator.payload[i]);
+		}
+		printk("\n");
+
+		break;
+	case FRAME_TYPE_NODE_ID_INDICATOR:
+		printk(KERN_DEBUG "%s(): Type: Node Identification Indicator\n", __func__);
+		printk(KERN_DEBUG "%s(): Sender Addr: %s\n", __func__,eui64_address_to_str(api_frame->api_data->node_id_indicator.sender_addr,eui64_addr_str));
+		printk(KERN_DEBUG "%s(): Sender Short Addr: %04X\n", __func__,api_frame->api_data->node_id_indicator.sender_short_addr);
+		if(api_frame->api_data->node_id_indicator.options & 0x01)
+			printk(KERN_DEBUG "%s(): Packet Acknowleged\n", __func__);
+		if(api_frame->api_data->node_id_indicator.options & 0x02)
+			printk(KERN_DEBUG "%s(): Packet was broadcast packet\n", __func__);
+		printk(KERN_DEBUG "%s(): Remote Short Addr: %04X\n", __func__,api_frame->api_data->node_id_indicator.src_short_addr);
+		printk(KERN_DEBUG "%s(): Remote Addr: %s\n", __func__,eui64_address_to_str(api_frame->api_data->node_id_indicator.src_addr,eui64_addr_str));
+		printk(KERN_DEBUG "%s(): Ni: \"%s\"\n", __func__,api_frame->api_data->node_id_indicator.ni_string);
+		printk(KERN_DEBUG "%s(): Remote Short Addr: %04X\n", __func__,api_frame->api_data->node_id_indicator.parent_short_addr);
+
+		break;
+	case FRAME_TYPE_REMOTE_CMD_RESP:
+		printk(KERN_DEBUG "%s(): Type: Remote Command Response\n", __func__);
+		printk(KERN_DEBUG "%s(): FrameID: %d\n", __func__,api_frame->api_data->remote_cmd_resp.frame_id);
+		printk(KERN_DEBUG "%s(): Src Addr: %s\n", __func__,eui64_address_to_str(api_frame->api_data->remote_cmd_resp.src_addr,eui64_addr_str));
+		printk(KERN_DEBUG "%s(): Reserved: %04X\n", __func__,api_frame->api_data->remote_cmd_resp.reserved);
+		printk(KERN_DEBUG "%s(): Command: %c%c\n", __func__,api_frame->api_data->remote_cmd_resp.at_command[0],api_frame->api_data->remote_cmd_resp.at_command[1]);
+		switch(api_frame->api_data->remote_cmd_resp.cmd_status)
+		{
+		case 0x00:
+			printk(KERN_DEBUG "%s(): Command Status: OK\n", __func__);
+			break;
+		case 0x01:
+			printk(KERN_DEBUG "%s(): Command Status: Error\n", __func__);
+			break;
+		case 0x02:
+			printk(KERN_DEBUG "%s(): Command Status: Invalid Command\n", __func__);
+			break;
+		case 0x03:
+			printk(KERN_DEBUG "%s(): Command Status: Invalid Parameter\n", __func__);
+			break;
+		default:
+			printk(KERN_DEBUG "%s(): Command Status: Unknown status 0x%02X\n", __func__,api_frame->api_data->remote_cmd_resp.cmd_status);
+			break;
+		}
+		if(api_frame->api_data->remote_cmd_resp.cmd_data_len)
+			printk(KERN_DEBUG "%s(): Parameter: %s\n", __func__,at_command_get_parameter_str(api_frame,str_aux));
+
+		break;
+	default:
+		printk(KERN_DEBUG "%s(): Type: Unknown (0x%02X)\n", __func__,api_frame->api_id);
+		break;
+	}
+
+	printk(KERN_DEBUG "%s(): ______________________________________________________\n", __func__);
+#endif
+}
+
+
+/*
+ * Escape helpers
+ */
+static int
+escape_required(uint8_t c)
+{
+	return ((XBEE_START_DELIM == c) ||
+			(XBEE_ESCAPE == c) ||
+			(XBEE_XON == c) ||
+			(XBEE_XOFF == c));
+}
+static int
+unescape_required(uint8_t c)
+{
+	return (XBEE_ESCAPE == c);
+}
+
+/*
+ * Received data processing
+ */
+
+static int
+_api_frame_process_response(_api_frame_t *api_frame)
+{
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: api_frame NULL pointer\n", __func__);
+		BUG();
+	}
+	pr_debug("%s(): api_frame request 0x%02X with response 0x%02X\n", __func__,api_frame->api_id,api_frame->response->api_id);
+	switch(api_frame->api_id)
+	{
+	// Requests
+	case FRAME_TYPE_AT_CMD:
+		if(api_frame->response->api_id != FRAME_TYPE_AT_CMD_RESP)
+		{
+			printk(KERN_WARNING "%s: invalid response type: 0x%02X (expected 0x%02X)\n", __func__,api_frame->response->api_id,FRAME_TYPE_AT_CMD_RESP);
+			return -EINVAL;
+		}
+		if(api_frame->response->api_data->at_cmd_resp.cmd_status != 0)
+		{
+			printk(KERN_DEBUG "%s: error issuing AT command: 0x%02X\n", __func__,api_frame->response->api_data->at_cmd_resp.cmd_status);
+			return -EINVAL;
+		}
+		break;
+	case FRAME_TYPE_AT_CMD_QUEUE:
+		if(api_frame->response->api_id != FRAME_TYPE_AT_CMD_RESP)
+		{
+			printk(KERN_WARNING "%s: invalid response type: 0x%02X (expected 0x%02X)\n", __func__,api_frame->response->api_id,FRAME_TYPE_AT_CMD_RESP);
+			return -EINVAL;
+		}
+		if(api_frame->response->api_data->at_cmd_resp.cmd_status != 0)
+		{
+			printk(KERN_DEBUG "%s: error issuing AT command: 0x%02X\n", __func__,api_frame->response->api_data->at_cmd_resp.cmd_status);
+			return -EINVAL;
+		}
+		break;
+	case FRAME_TYPE_TRANSMIT_REQ:
+		if(api_frame->response->api_id != FRAME_TYPE_TRANSMIT_STATUS1 && api_frame->response->api_id != FRAME_TYPE_TRANSMIT_STATUS2)
+		{
+			printk(KERN_WARNING "%s: invalid response type: 0x%02X (expected 0x%02X)\n", __func__,api_frame->response->api_id,FRAME_TYPE_TRANSMIT_STATUS1);
+			return -EINVAL;
+		}
+		if(api_frame->response->api_data->transmit_status.delivery_status)
+		{
+			printk(KERN_DEBUG "%s: error transmitting data: 0x%02X retries: %d disc: 0x%02X\n", __func__,
+					api_frame->response->api_data->transmit_status.delivery_status,
+					api_frame->response->api_data->transmit_status.transmit_retry_count,
+					api_frame->response->api_data->transmit_status.discovery_status);
+			return -EAGAIN;
+		}
+		break;
+
+	case FRAME_TYPE_RAW_TRANSMIT_REQ:
+		if(api_frame->response->api_id != FRAME_TYPE_RAW_TRANSMIT_STATUS)
+		{
+			printk(KERN_WARNING "%s: invalid response type: 0x%02X (expected 0x%02X)\n", __func__,api_frame->response->api_id,FRAME_TYPE_RAW_TRANSMIT_STATUS);
+			return -EINVAL;
+		}
+		if(api_frame->response->api_data->raw_transmit_status.delivery_status)
+		{
+			printk(KERN_DEBUG "%s: error transmitting data: 0x%02X\n", __func__,
+					api_frame->response->api_data->raw_transmit_status.delivery_status);
+			return -EAGAIN;
+		}
+		break;
+
+	case FRAME_TYPE_EXPLICIT_ADDR_CMD:
+		if(api_frame->response->api_id != FRAME_TYPE_TRANSMIT_STATUS1 && api_frame->response->api_id != FRAME_TYPE_TRANSMIT_STATUS2)
+		{
+			printk(KERN_WARNING "%s: invalid response type: 0x%02X (expected 0x%02X)\n", __func__,api_frame->response->api_id,FRAME_TYPE_TRANSMIT_STATUS1);
+			return -EINVAL;
+		}
+		if(api_frame->response->api_data->transmit_status.delivery_status)
+		{
+			printk(KERN_DEBUG "%s: error transmitting data: 0x%02X\n", __func__,api_frame->response->api_data->transmit_status.delivery_status);
+			return -EAGAIN;
+		}
+		break;
+	case FRAME_TYPE_REMOTE_AT_CMD_REQ:
+		if(api_frame->response->api_id != FRAME_TYPE_REMOTE_CMD_RESP)
+		{
+			printk(KERN_WARNING "%s: invalid response type: 0x%02X (expected 0x%02X)\n", __func__,api_frame->response->api_id,FRAME_TYPE_REMOTE_CMD_RESP);
+			return -EINVAL;
+		}
+		if(api_frame->response->api_data->remote_cmd_resp.cmd_status != 0)
+		{
+			printk(KERN_DEBUG "%s: error issuing AT command: 0x%02X\n", __func__,api_frame->response->api_data->remote_cmd_resp.cmd_status);
+			return -EINVAL;
+		}
+		break;
+
+	// Responses
+//	case FRAME_TYPE_AT_CMD_RESP:
+//		return 1;
+//		break;
+//	case FRAME_TYPE_MODEM_STATUS:
+//		return 1;
+//		break;
+//	case FRAME_TYPE_TRANSMIT_STATUS:
+//		return 1;
+//		break;
+//	case FRAME_TYPE_RECEIVE_PACKET:
+//		return 1;
+//		break;
+//	case FRAME_TYPE_EXPLICIT_RX_INDICATOR:
+//		return 1;
+//		break;
+//	case FRAME_TYPE_NODE_ID_INDICATOR:
+//		return 1;
+//		break;
+//	case FRAME_TYPE_REMOTE_CMD_RESP:
+//		return 1;
+//		break;
+	default:
+		printk(KERN_WARNING "%s(): Invalid Request Type (0x%02X)\n", __func__,api_frame->api_id);
+		break;
+		return 0;
+	}
+	return 0;
+}
+
+static void
+ieee802154_net_rx(struct xbee_device *xbee_dev, _api_frame_t *api_frame);
+
+static int
+_api_frame_process(struct xbee_device *xbee_dev, _api_frame_t *api_frame)
+{
+	int ret = 0;
+	if(xbee_dev == NULL)
+	{
+		printk(KERN_ERR "%s: xbee_dev NULL pointer\n", __func__);
+		BUG();
+	}
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: api_frame NULL pointer\n", __func__);
+		BUG();
+	}
+
+#ifdef	DEBUG
+	printk(KERN_INFO "%s(): Call process frame\n", __func__);
+#endif
+
+	//_api_frame_print(api_frame);
+
+	if(_api_frame_should_signal_pendent(api_frame))
+	{
+		xbee_device_signal_pendent_req(xbee_dev,api_frame);
+	}
+	else
+	{
+		//TODO: not pendent request response
+		_api_frame_print(api_frame);
+
+		//FIXME we should only push to stack the received_packets frames or RAW
+		ieee802154_net_rx(xbee_dev,api_frame);
+
+		_api_frame_free(api_frame);
+		api_frame = NULL;
+	}
+
+	return ret;
+}
+
+static int
+xbee_process_char(struct xbee_device *xbee_dev, unsigned char c)
+{
+	_api_frame_t *api_frame = NULL;
+//#ifdef	DEBUG
+//	printk(KERN_INFO "%s(): current state %s\n", __func__,
+//			xbee_recv_state_str(xbee_dev->recv_state));
+//
+//	printk(KERN_INFO "%s(): processing %3d (0x%02X)\n", __func__,c,c);
+//#endif
+
+	/* Data processing */
+	switch (xbee_dev->recv_state) {
+	case RECV_STATE_WAIT_START_DELIM:
+		if (XBEE_START_DELIM == c)
+		{
+			xbee_dev->recv_state = RECV_STATE_WAIT_MSB;
+		}
+		break;
+	case RECV_STATE_WAIT_MSB:
+		xbee_dev->recv_data_size = c;
+		xbee_dev->recv_state = RECV_STATE_WAIT_LSB;
+		break;
+	case RECV_STATE_WAIT_LSB:
+
+		if(xbee_dev->recv_data)
+		{
+			printk(KERN_INFO "%s(): we shouldnt get data buffers here!\n",__func__);
+		}
+
+		xbee_dev->recv_data_size <<= 8;
+		xbee_dev->recv_data_size += c;
+		xbee_dev->recv_state = RECV_STATE_WAIT_DATA;
+
+#ifdef __KERNEL__
+		xbee_dev->recv_data = kzalloc(xbee_dev->recv_data_size, GFP_KERNEL);
+#else
+		xbee_dev->recv_data = calloc(xbee_dev->recv_data_size,sizeof(uint8_t));
+#endif
+		if (!xbee_dev->recv_data) {
+			printk(KERN_ERR "%s(): unable to allocate memory\n", __func__);
+			xbee_dev->recv_data_size = 0;
+			return -ENOMEM;
+		}
+
+		xbee_dev->recv_data_offset = 0;
+		xbee_dev->recv_data_sum = 0;
+
+#ifndef __KERNEL__
+#ifdef	DEBUG
+		printk(KERN_INFO "%s(): Got payload length: %"PRIu16"\n", __func__,xbee_dev->recv_data_size);
+#endif
+#endif
+
+		break;
+	case RECV_STATE_WAIT_DATA:
+//#ifdef	DEBUG
+//		printk(KERN_INFO "%s(): processing: index data[%u]\n", __func__,xbee_dev->recv_data_offset);
+//#endif
+		xbee_dev->recv_data_sum += c;
+		xbee_dev->recv_data[xbee_dev->recv_data_offset++] = c;
+		if(xbee_dev->recv_data_offset == xbee_dev->recv_data_size)
+		{
+			xbee_dev->recv_state = RECV_STATE_WAIT_CHECKSUM;
+		}
+		break;
+	case RECV_STATE_WAIT_CHECKSUM:
+		if(0xFF - xbee_dev->recv_data_sum != c)
+		{
+			printk(KERN_WARNING "%s(): checksum failed: got 0x%02X (expected 0x%02X)\n", __func__,c,0xFF - xbee_dev->recv_data_sum);
+			printk(KERN_WARNING "%s(): Error parsing frame: discarding\n", __func__);
+			printk(KERN_WARNING "%s(): received %d bytes\n", __func__,xbee_dev->recv_data_size);
+			print_hex_dump_bytes("xbee_process_char(): ", DUMP_PREFIX_NONE, xbee_dev->recv_data, xbee_dev->recv_data_size);
+
+#ifdef __KERNEL__
+			if(xbee_dev->recv_data)
+				kfree(xbee_dev->recv_data);
+#else
+				free(xbee_dev->recv_data);
+#endif
+			xbee_dev->recv_data = NULL;
+			xbee_dev->recv_data_offset = 0;
+			xbee_dev->recv_data_escape_next = 0;
+			xbee_dev->recv_data_sum = 0;
+			xbee_dev->recv_data_size = 0;
+		}
+		else
+		{
+#ifdef	DEBUG
+		printk(KERN_INFO "%s(): Got valid frame\n", __func__);
+#endif
+			api_frame = _api_frame_parse(xbee_dev->recv_data_size,xbee_dev->recv_data,c);
+			if(api_frame)
+			{
+				xbee_dev->recv_data = NULL;
+				xbee_dev->recv_data_offset = 0;
+				xbee_dev->recv_data_escape_next = 0;
+				xbee_dev->recv_data_sum = 0;
+				xbee_dev->recv_data_size = 0;
+				if(_api_frame_process(xbee_dev,api_frame))
+				{
+					printk(KERN_WARNING "%s(): error processing frame\n", __func__);
+				}
+				api_frame = NULL;
+			}
+			else
+			{
+				printk(KERN_WARNING "%s(): Error parsing frame: discarding\n", __func__);
+#ifdef __KERNEL__
+				if(xbee_dev->recv_data)
+					kfree(xbee_dev->recv_data);
+#else
+					free(xbee_dev->recv_data);
+#endif
+				xbee_dev->recv_data = NULL;
+				xbee_dev->recv_data_offset = 0;
+				xbee_dev->recv_data_escape_next = 0;
+				xbee_dev->recv_data_sum = 0;
+				xbee_dev->recv_data_size = 0;
+			}
+		}
+
+		xbee_dev->recv_state = RECV_STATE_WAIT_START_DELIM;
+		wake_up(&xbee_dev->wq);
+
+		break;
+	default:
+		BUG(); //FIXME check if we can reach this point
+		break;
+	}
+	return 0;
+}
+
+static int
+xbee_receive(struct xbee_device *xbee_dev, const unsigned char *buf, int count)
+{
+	uint8_t rx_data = 0;
+	int i = 0;
+	if(xbee_dev == NULL)
+	{
+		printk(KERN_ERR "%s: xbee_dev NULL pointer\n", __func__);
+		BUG();
+	}
+	if(buf == NULL)
+	{
+		printk(KERN_ERR "%s: buf NULL pointer\n", __func__);
+		BUG();
+	}
+	for (i=0; i < count; ++i){
+		rx_data = buf[i];
+		if(xbee_dev->recv_state != RECV_STATE_WAIT_START_DELIM && xbee_dev->escaped_mode) {
+			if(unescape_required(rx_data))
+			{
+				xbee_dev->recv_data_escape_next = 1;
+			}
+			else if(xbee_dev->recv_data_escape_next)
+			{
+				xbee_dev->recv_data_escape_next = 0;
+				rx_data = buf[i]^0x20;
+				xbee_process_char(xbee_dev, rx_data);
+			} else {
+				xbee_process_char(xbee_dev, rx_data);
+			}
+		} else {
+			xbee_process_char(xbee_dev, rx_data);
+		}
+	}
+	return 0;
+}
+
+static int
+xbee_send(struct xbee_device *xbee_dev, _api_frame_t *api_frame)
+{
+	int ret = 0;
+#ifndef __KERNEL__
+	struct timeval tv = {0,0};
+	struct timespec waitspec = {0,0};
+	//pthread_attr_t attr;
+#endif
+
+	uint16_t len = 0;
+	uint8_t *raw_frame = NULL;
+	if(xbee_dev == NULL)
+	{
+		printk(KERN_ERR "%s: xbee_dev NULL pointer\n", __func__);
+		BUG();
+	}
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: api_frame NULL pointer\n", __func__);
+		BUG();
+	}
+
+	raw_frame = _api_frame_to_raw(api_frame,&len);
+
+	if(raw_frame  == NULL)
+	{
+		printk(KERN_ERR "%s: raw_frame NULL pointer\n", __func__);
+		BUG();
+	}
+
+	if(_api_frame_should_wait_response(api_frame))
+	{
+		xbee_device_add_pendent_req(xbee_dev,api_frame);
+	}
+
+	if((ret = xbee_device_write_to_phy(xbee_dev,raw_frame,len)) != len)
+	{
+		printk(KERN_ERR "%s: error writing to phy media: ret: %d len: %u\n", __func__,ret,len);
+		BUG(); // FIXME
+		/*
+		 * [ 1034.907503] xbee_send: error writing to phy media
+[ 1034.924140] ------------[ cut here ]------------
+[ 1034.928770] kernel BUG at drivers/net/ieee802154/xbee.c:2177!
+[ 1034.934507] Internal error: Oops - BUG: 0 [#1] PREEMPT ARM
+
+Entering kdb (current=0xda84a080, pid 6) Oops: (null)
+due to oops @ 0xbf1a4ed0
+
+Pid: 6, comm:          kworker/u:0
+CPU: 0    Not tainted  (3.9.6+ #1)
+PC is at xbee_send+0x12c/0x854 [xbee]
+LR is at xbee_send+0x12c/0x854 [xbee]
+pc : [<bf1a4ed0>]    lr : [<bf1a4ed0>]    psr: 60000113
+sp : da851e90  ip : 60000113  fp : 00000089
+r10: 0000006f  r9 : da850000  r8 : 00000000
+r7 : 0000006f  r6 : d99b49e0  r5 : d8511b40  r4 : da9c2660
+r3 : 00000000  r2 : c057f344  r1 : c0571a80  r0 : 00000025
+Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
+Control: 00c5387d  Table: 1aac0008  DAC: 00000017
+		 *
+		 */
+	} else {
+		ret = 0;
+	}
+
+	if(raw_frame)
+	{
+#ifdef __KERNEL__
+		kfree(raw_frame);
+#else
+		free(raw_frame);
+#endif
+		raw_frame = NULL;
+	}
+
+	if(_api_frame_should_wait_response(api_frame))
+	{
+		//xbee_device_add_pendent_req(xbee_dev,api_frame);
+#ifdef __KERNEL__
+		INIT_COMPLETION(api_frame->complete);
+		ret = wait_for_completion_interruptible_timeout(
+							&api_frame->complete,
+							2 * HZ);
+		if (ret == -ERESTARTSYS){
+			xbee_device_remove_pendent_req(xbee_dev,api_frame);
+			goto err;
+		}
+		if (ret == 0) {
+			xbee_device_remove_pendent_req(xbee_dev,api_frame);
+			ret = -ETIMEDOUT;
+			goto err;
+		}
+#else
+		printk(KERN_DEBUG "%s: waiting for response...\n", __func__);
+		gettimeofday(&tv,NULL);
+		waitspec.tv_sec = tv.tv_sec + 5;
+		waitspec.tv_nsec = 0;
+		pthread_mutex_lock(&api_frame->mutex);
+		ret = pthread_cond_timedwait(&api_frame->complete,&api_frame->mutex,&waitspec);
+		if(ret != 0 && ret != ETIMEDOUT){
+			printk(KERN_ERR "%s: some error occur waiting for status to change: %d", __func__, ret);
+			pthread_mutex_unlock(&api_frame->mutex);
+			goto err;
+		}
+		pthread_mutex_unlock(&api_frame->mutex);
+		if(ret == ETIMEDOUT){
+			printk(KERN_DEBUG "%s: timeout!!!\n", __func__);
+			goto err;
+		}else{
+			printk(KERN_DEBUG "%s: response received\n", __func__);
+		}
+#endif
+		xbee_device_remove_pendent_req(xbee_dev,api_frame);
+		if(!api_frame->response)
+		{
+			printk(KERN_DEBUG "%s: response not available\n", __func__);
+			ret = -EBUSY;
+			goto err;
+		}
+		ret = _api_frame_process_response(api_frame);
+		if(ret)
+		{
+			printk(KERN_DEBUG "%s: error in response\n", __func__);
+			goto err;
+		}
+	}
+
+
+err:
+	pr_debug("%s(): ret: %d\n", __func__,ret);
+	return ret;
+}
+
+/*
+ * Frame API AT Command
+ */
+
+static _api_frame_t *
+_api_frame_new_at_command(struct xbee_device *xbee_dev,const char cmdid[3])
+{
+	_api_frame_t *api_frame = NULL;
+	api_frame = _api_frame_alloc(4,sizeof(api_frame_at_cmd_t));
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->at_cmd.api_id = FRAME_TYPE_AT_CMD;
+	api_frame->api_data->at_cmd.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	api_frame->api_data->at_cmd.at_command[0] = cmdid[0];
+	api_frame->api_data->at_cmd.at_command[1] = cmdid[1];
+	api_frame->api_data->at_cmd.parameter_value_len = 0;
+	return api_frame;
+}
+
+static _api_frame_t *
+_api_frame_new_at_command_u8(struct xbee_device *xbee_dev,const char cmdid[3],uint8_t arg)
+{
+	_api_frame_t *api_frame = NULL;
+	api_frame = _api_frame_alloc(5,sizeof(api_frame_at_cmd_t));
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->at_cmd.api_id = FRAME_TYPE_AT_CMD;
+	api_frame->api_data->at_cmd.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	api_frame->api_data->at_cmd.at_command[0] = cmdid[0];
+	api_frame->api_data->at_cmd.at_command[1] = cmdid[1];
+	api_frame->api_data->at_cmd.parameter_value[0] = arg;
+	api_frame->api_data->at_cmd.parameter_value_len = 1;
+	return api_frame;
+}
+
+static _api_frame_t *
+_api_frame_new_at_command_u16(struct xbee_device *xbee_dev,const char cmdid[3],uint8_t arg[2])
+{
+	_api_frame_t *api_frame = NULL;
+	api_frame = _api_frame_alloc(6,sizeof(api_frame_at_cmd_t));
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->at_cmd.api_id = FRAME_TYPE_AT_CMD;
+	api_frame->api_data->at_cmd.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	api_frame->api_data->at_cmd.at_command[0] = cmdid[0];
+	api_frame->api_data->at_cmd.at_command[1] = cmdid[1];
+	api_frame->api_data->at_cmd.parameter_value[0] = arg[0];
+	api_frame->api_data->at_cmd.parameter_value[1] = arg[1];
+	api_frame->api_data->at_cmd.parameter_value_len = 2;
+	return api_frame;
+}
+
+static _api_frame_t *
+_api_frame_new_at_command_u32(struct xbee_device *xbee_dev,const char cmdid[3],uint8_t arg[4])
+{
+	_api_frame_t *api_frame = NULL;
+	api_frame = _api_frame_alloc(8,sizeof(api_frame_at_cmd_t));
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->at_cmd.api_id = FRAME_TYPE_AT_CMD;
+	api_frame->api_data->at_cmd.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	api_frame->api_data->at_cmd.at_command[0] = cmdid[0];
+	api_frame->api_data->at_cmd.at_command[1] = cmdid[1];
+	api_frame->api_data->at_cmd.parameter_value[0] = arg[0];
+	api_frame->api_data->at_cmd.parameter_value[1] = arg[1];
+	api_frame->api_data->at_cmd.parameter_value[2] = arg[2];
+	api_frame->api_data->at_cmd.parameter_value[3] = arg[3];
+	api_frame->api_data->at_cmd.parameter_value_len = 4;
+	return api_frame;
+}
+
+/*
+ * Frame API AT Command - Queue Parameter Value
+ */
+
+static _api_frame_t *
+_api_frame_new_at_command_queue(struct xbee_device *xbee_dev,const char cmdid[3])
+{
+	_api_frame_t *api_frame = NULL;
+	api_frame = _api_frame_alloc(4,sizeof(api_frame_at_cmd_queue_t));
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->at_cmd_queue.api_id = FRAME_TYPE_AT_CMD_QUEUE;
+	api_frame->api_data->at_cmd_queue.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	api_frame->api_data->at_cmd_queue.at_command[0] = cmdid[0];
+	api_frame->api_data->at_cmd_queue.at_command[1] = cmdid[1];
+	api_frame->api_data->at_cmd_queue.parameter_value_len = 0;
+	return api_frame;
+}
+
+static _api_frame_t *
+_api_frame_new_at_command_queue_u8(struct xbee_device *xbee_dev,const char cmdid[3],uint8_t arg)
+{
+	_api_frame_t *api_frame = NULL;
+	api_frame = _api_frame_alloc(5,sizeof(api_frame_at_cmd_queue_t));
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->at_cmd_queue.api_id = FRAME_TYPE_AT_CMD_QUEUE;
+	api_frame->api_data->at_cmd_queue.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	api_frame->api_data->at_cmd_queue.at_command[0] = cmdid[0];
+	api_frame->api_data->at_cmd_queue.at_command[1] = cmdid[1];
+	api_frame->api_data->at_cmd_queue.parameter_value[0] = arg;
+	api_frame->api_data->at_cmd_queue.parameter_value_len = 1;
+	return api_frame;
+}
+
+static _api_frame_t *
+_api_frame_new_at_command_queue_u16(struct xbee_device *xbee_dev,const char cmdid[3],uint8_t arg[2])
+{
+	_api_frame_t *api_frame = NULL;
+	api_frame = _api_frame_alloc(6,sizeof(api_frame_at_cmd_queue_t));
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->at_cmd_queue.api_id = FRAME_TYPE_AT_CMD_QUEUE;
+	api_frame->api_data->at_cmd_queue.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	api_frame->api_data->at_cmd_queue.at_command[0] = cmdid[0];
+	api_frame->api_data->at_cmd_queue.at_command[1] = cmdid[1];
+	api_frame->api_data->at_cmd_queue.parameter_value[0] = arg[0];
+	api_frame->api_data->at_cmd_queue.parameter_value[1] = arg[1];
+	api_frame->api_data->at_cmd_queue.parameter_value_len = 2;
+	return api_frame;
+}
+
+static _api_frame_t *
+_api_frame_new_at_command_queue_u32(struct xbee_device *xbee_dev,const char cmdid[3],uint8_t arg[4])
+{
+	_api_frame_t *api_frame = NULL;
+	api_frame = _api_frame_alloc(8,sizeof(api_frame_at_cmd_queue_t));
+	if(api_frame == NULL)
+	{
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->at_cmd_queue.api_id = FRAME_TYPE_AT_CMD_QUEUE;
+	api_frame->api_data->at_cmd_queue.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	api_frame->api_data->at_cmd_queue.at_command[0] = cmdid[0];
+	api_frame->api_data->at_cmd_queue.at_command[1] = cmdid[1];
+	api_frame->api_data->at_cmd_queue.parameter_value[0] = arg[0];
+	api_frame->api_data->at_cmd_queue.parameter_value[1] = arg[1];
+	api_frame->api_data->at_cmd_queue.parameter_value[2] = arg[2];
+	api_frame->api_data->at_cmd_queue.parameter_value[3] = arg[3];
+	api_frame->api_data->at_cmd_queue.parameter_value_len = 4;
+	return api_frame;
+}
+
+/*
+ * Frame API Transmit Request
+ */
+
+static _api_frame_t *
+_api_frame_new_transmit_request(struct xbee_device *xbee_dev,
+		uint8_t dst_addr[XBEE_ADDR_LEN], uint8_t options, uint8_t *payload,
+		uint16_t payload_len) {
+	_api_frame_t *api_frame = NULL;
+	size_t frame_len = 1 /* frame type */ +
+			1 /* frameID*/ +
+			XBEE_ADDR_LEN +
+			2 /* reserved */ +
+			1 /* broadcast radius */ +
+			1 /* transmit options */ +
+			payload_len;
+	api_frame = _api_frame_alloc(frame_len,sizeof(api_frame_transmit_req_t));
+	if (api_frame == NULL ) {
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->transmit_req.api_id = FRAME_TYPE_TRANSMIT_REQ;
+	api_frame->api_data->transmit_req.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	memcpy(api_frame->api_data->transmit_req.dst_addr, dst_addr, XBEE_ADDR_LEN);
+	api_frame->api_data->transmit_req.reserved = 0xFFFE;
+	api_frame->api_data->transmit_req.brd_radius = XBEE_DEFAULT_BROADCAST_RADIUS;
+	api_frame->api_data->transmit_req.options = options;
+	api_frame->api_data->transmit_req.payload = payload;
+	api_frame->api_data->transmit_req.payload_len = payload_len;
+	return api_frame;
+}
+
+/*
+ * Frame API IEEE 802.15.4 Raw Packet
+ */
+
+static _api_frame_t *
+_api_frame_new_raw_packet(struct xbee_device *xbee_dev, uint8_t *payload, uint16_t payload_len) {
+	_api_frame_t *api_frame = NULL;
+	size_t frame_len = 1 /* frame type */ +
+			payload_len;
+	api_frame = _api_frame_alloc(frame_len,sizeof(api_frame_transmit_req_t));
+	if (api_frame == NULL ) {
+		printk(KERN_ERR "%s: error creating api_frame\n", __func__);
+		BUG();
+	}
+	api_frame->api_id = api_frame->api_data->raw_packet.api_id = FRAME_TYPE_RAW_TRANSMIT_REQ;
+	api_frame->api_data->raw_packet.frame_id = _xbee_device_gen_frame_id(xbee_dev);
+	api_frame->api_data->raw_packet.payload = payload;
+	api_frame->api_data->raw_packet.payload_len = payload_len;
+	return api_frame;
+}
+
+/*
+ * Frame API Explicit Addressing Command
+ */
+
+//static _api_frame_t *
+//_api_frame_new_explicit_addressing(struct xbee_device *xbee_dev,
+//		uint8_t dst_addr[XBEE_ADDR_LEN], uint8_t options, uint8_t *payload,
+//		uint16_t payload_len) {
+//	//TODO: _api_frame_new_explicit_addressing: not implemented
+//	return NULL;
+//}
+
+/*
+ * Frame API Remote AT Command Request
+ */
+
+//static _api_frame_t *
+//_api_frame_new_remote_at_command(struct xbee_device *xbee_dev,
+//		uint8_t dst_addr[XBEE_ADDR_LEN], const char cmdid[3]) {
+//	//TODO: _api_frame_new_remote_at_command_u32: not implemented
+//	return NULL ;
+//}
+//
+//static _api_frame_t *
+//_api_frame_new_remote_at_command_u8(struct xbee_device *xbee_dev,
+//		uint8_t dst_addr[XBEE_ADDR_LEN], const char cmdid[3], uint8_t arg[1]) {
+//	//TODO: _api_frame_new_remote_at_command_u8: not implemented
+//	return NULL ;
+//}
+//
+//static _api_frame_t *
+//_api_frame_new_remote_at_command_u16(struct xbee_device *xbee_dev,
+//		uint8_t dst_addr[XBEE_ADDR_LEN], const char cmdid[3], uint8_t arg[2]) {
+//	//TODO: _api_frame_new_remote_at_command_u16: not implemented
+//	return NULL ;
+//}
+//
+//static _api_frame_t *
+//_api_frame_new_remote_at_command_u32(struct xbee_device *xbee_dev,
+//		uint8_t dst_addr[XBEE_ADDR_LEN], const char cmdid[3], uint8_t arg[4]) {
+//	//TODO: _api_frame_new_remote_at_command_u32: not implemented
+//	return NULL ;
+//}
+
+/*
+ * XBee AT Command Read 32 bit parameter
+ */
+
+static int
+xbee_api_at_command_read_uN(struct xbee_device *xbee_dev, const char cmdid[3], uint8_t value[4], uint8_t len)
+{
+	int ret = 0;
+	int i = 0;
+	_api_frame_t *api_frame = NULL;
+
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong xbee device\n", __func__);
+		return -EINVAL;
+	}
+
+	api_frame = _api_frame_new_at_command(xbee_dev,cmdid);
+
+	ret = xbee_send(xbee_dev,api_frame);
+
+	if(ret)
+	{
+		printk(KERN_ERR "%s: error sending API frame: %s: %d\n", __func__,cmdid,ret);
+		goto err;
+	}
+
+	if(!api_frame->response)
+	{
+		printk(KERN_ERR "%s: response is NULL\n", __func__);
+		ret = -EAGAIN;
+		goto err;
+	}
+
+	if(api_frame->response->api_data->at_cmd_resp.cmd_data_len != len)
+	{
+		printk(KERN_ERR "%s: invalid response value len\n", __func__);
+		ret = -EAGAIN;
+		goto err;
+	}
+
+	_api_frame_print(api_frame);
+	if(api_frame && api_frame->response)
+		_api_frame_print(api_frame->response);
+
+	for(i=0;i<api_frame->response->api_data->at_cmd_resp.cmd_data_len;i++)
+	{
+		value[i] = api_frame->response->api_data->at_cmd_resp.cmd_data[i];
+	}
+
+	pr_debug("%s(): xbee_send ret: %d\n", __func__,ret);
+
+err:
+	if(api_frame)
+	{
+		_api_frame_free(api_frame);
+	}
+
+	return 0;
+}
+
+static int
+xbee_api_at_command_read_u8(struct xbee_device *xbee_dev, const char cmdid[3], uint8_t value[1])
+{
+	return xbee_api_at_command_read_uN(xbee_dev,cmdid,value,1);
+}
+
+static int
+xbee_api_at_command_read_u16(struct xbee_device *xbee_dev, const char cmdid[3], uint8_t value[2])
+{
+	return xbee_api_at_command_read_uN(xbee_dev,cmdid,value,2);
+}
+
+static int
+xbee_api_at_command_read_u32(struct xbee_device *xbee_dev, const char cmdid[3], uint8_t value[4])
+{
+	return xbee_api_at_command_read_uN(xbee_dev,cmdid,value,4);
+}
+
+#ifndef __KERNEL__
+static void
+dump_hex(uint8_t *buf, int len);
+#endif
+
+//static int
+//xbee_ieee_address(struct xbee_device *xbee_dev, uint8_t addr[IEEE802154_ADDR_LEN])
+////xbee_ieee_address(struct ieee802154_dev *dev, uint8_t addr[IEEE802154_ADDR_LEN])
+//{
+//	//struct xbee_device *xbee_dev = NULL;
+//
+////	uint8_t serial_number_high[4] = {};
+////	uint8_t serial_number_low[4] = {};
+//
+//	int ret = 0;
+//	pr_debug("%s\n", __func__);
+//
+//	//xbee_dev = dev->priv;
+//	if (NULL == xbee_dev) {
+//		printk(KERN_ERR "%s: wrong phy\n", __func__);
+//		return -EINVAL;
+//	}
+//
+//	//ret = xbee_api_at_command_read_u32(xbee_dev,"SH",serial_number_high);
+//	ret = xbee_api_at_command_read_u32(xbee_dev,"SH",addr);
+//	if(ret)
+//	{
+//		printk(KERN_ERR "%s: error getting serial high value\n", __func__);
+//		return ret;
+//	}
+//	//dump_hex(serial_number_high, 4); printf("\n");
+//
+//	//ret = xbee_api_at_command_read_u32(xbee_dev,"SL",serial_number_low);
+//	ret = xbee_api_at_command_read_u32(xbee_dev,"SL",addr+4);
+//	if(ret)
+//	{
+//		printk(KERN_ERR "%s: error getting serial low value\n", __func__);
+//		return ret;
+//	}
+//	//dump_hex(serial_number_low, 4); printf("\n");
+//
+//#ifndef __KERNEL__
+//	dump_hex(addr, 8); printf("\n");
+//#endif
+//	pr_debug("%s end\n", __func__);
+//	return ret;
+//}
+
+static uint8_t
+xbee_get_rssi(struct ieee802154_dev *dev)
+{
+	struct xbee_device *xbee_dev = NULL;
+	uint8_t result = 0x00;
+	int ret = 0;
+	pr_debug("%s\n", __func__);
+
+	xbee_dev = dev->priv;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = xbee_api_at_command_read_u8(xbee_dev,"DB",&result);
+	if(ret)
+	{
+		printk(KERN_ERR "%s: error getting RSSI value\n", __func__);
+		return ret;
+	}
+
+	global_lqi = result;
+
+#ifndef __KERNEL__
+	dump_hex(addr, 8); printf("\n");
+#endif
+	pr_debug("%s end\n", __func__);
+	return result;
+}
+
+//static uint16_t
+//xbee_get_pan_id(struct ieee802154_dev *dev)
+//{
+//	struct xbee_device *xbee_dev = NULL;
+//	uint8_t at_cmd_result[4] = {0,0,0,0};
+//	uint16_t result = 0x0000;
+//	int ret = 0;
+//	pr_debug("%s\n", __func__);
+//
+//	xbee_dev = dev->priv;
+//	if (NULL == xbee_dev) {
+//		printk(KERN_ERR "%s: wrong phy\n", __func__);
+//		return -EINVAL;
+//	}
+//
+//	ret = xbee_api_at_command_read_u16(xbee_dev,"ID",&at_cmd_result);
+//	if(ret)
+//	{
+//		printk(KERN_ERR "%s: error getting network id value\n", __func__);
+//		return ret;
+//	}
+//#ifndef __KERNEL__
+//	dump_hex(addr, 8); printf("\n");
+//#endif
+//	result = ((at_cmd_result[0] << 8) & 0xFF00) + (at_cmd_result[1] & 0xFF);
+//
+//	pr_debug("%s end\n", __func__);
+//	return result;
+//}
+
+static uint8_t
+xbee_get_dsn(struct ieee802154_dev *dev)
+{
+	struct xbee_device *xbee_dev = NULL;
+	uint8_t dsn = 0x00;
+	pr_debug("%s\n", __func__);
+
+	xbee_dev = dev->priv;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return -EINVAL;
+	}
+
+#ifdef __KERNEL__
+	mutex_lock(&xbee_dev->mutex);
+#else
+	pthread_mutex_lock(&xbee_dev->mutex);
+#endif
+	dsn = xbee_dev->frame_id_counter;
+#ifdef __KERNEL__
+	mutex_unlock(&xbee_dev->mutex);
+#else
+	pthread_mutex_unlock(&xbee_dev->mutex);
+#endif
+
+	pr_debug("%s end\n", __func__);
+	return dsn;
+}
+
+#ifdef __KERNEL__
+
+/*
+ * MAC802154 parsing functions
+ */
+
+static inline int mac802154_fetch_skb_u8(struct sk_buff *skb, u8 *val)
+{
+	if (unlikely(!pskb_may_pull(skb, 1)))
+		return -EINVAL;
+
+	*val = skb->data[0];
+	skb_pull(skb, 1);
+
+	return 0;
+}
+
+static inline int mac802154_fetch_skb_u16(struct sk_buff *skb, u16 *val)
+{
+	if (unlikely(!pskb_may_pull(skb, 2)))
+		return -EINVAL;
+
+	*val = skb->data[0] | (skb->data[1] << 8);
+	skb_pull(skb, 2);
+
+	return 0;
+}
+
+static inline void mac802154_haddr_copy_swap(u8 *dest, const u8 *src)
+{
+	int i;
+	for (i = 0; i < IEEE802154_ADDR_LEN; i++)
+		dest[IEEE802154_ADDR_LEN - i - 1] = src[i];
+}
+
+static int mac802154_parse_frame_start(struct sk_buff *skb)
+{
+	u8 *head = skb->data;
+	u16 fc;
+
+	if (mac802154_fetch_skb_u16(skb, &fc) ||
+	    mac802154_fetch_skb_u8(skb, &(mac_cb(skb)->seq)))
+		goto err;
+
+	pr_debug("fc: %04x dsn: %02x\n", fc, head[2]);
+
+	mac_cb(skb)->flags = IEEE802154_FC_TYPE(fc);
+	mac_cb(skb)->sa.addr_type = IEEE802154_FC_SAMODE(fc);
+	mac_cb(skb)->da.addr_type = IEEE802154_FC_DAMODE(fc);
+
+	if (fc & IEEE802154_FC_INTRA_PAN)
+		mac_cb(skb)->flags |= MAC_CB_FLAG_INTRAPAN;
+
+	if (mac_cb(skb)->da.addr_type != IEEE802154_ADDR_NONE) {
+		if (mac802154_fetch_skb_u16(skb, &(mac_cb(skb)->da.pan_id)))
+			goto err;
+
+		/* source PAN id compression */
+		if (mac_cb_is_intrapan(skb))
+			mac_cb(skb)->sa.pan_id = mac_cb(skb)->da.pan_id;
+
+		pr_debug("dest PAN addr: %04x\n", mac_cb(skb)->da.pan_id);
+
+		if (mac_cb(skb)->da.addr_type == IEEE802154_ADDR_SHORT) {
+			u16 *da = &(mac_cb(skb)->da.short_addr);
+
+			if (mac802154_fetch_skb_u16(skb, da))
+				goto err;
+
+			pr_debug("destination address is short: %04x\n",
+				 mac_cb(skb)->da.short_addr);
+		} else {
+			if (!pskb_may_pull(skb, IEEE802154_ADDR_LEN))
+				goto err;
+
+			mac802154_haddr_copy_swap(mac_cb(skb)->da.hwaddr,
+						  skb->data);
+			skb_pull(skb, IEEE802154_ADDR_LEN);
+
+			pr_debug("destination address is hardware\n");
+		}
+	}
+
+	if (mac_cb(skb)->sa.addr_type != IEEE802154_ADDR_NONE) {
+		/* non PAN-compression, fetch source address id */
+		if (!(mac_cb_is_intrapan(skb))) {
+			u16 *sa_pan = &(mac_cb(skb)->sa.pan_id);
+
+			if (mac802154_fetch_skb_u16(skb, sa_pan))
+				goto err;
+		}
+
+		pr_debug("source PAN addr: %04x\n", mac_cb(skb)->da.pan_id);
+
+		if (mac_cb(skb)->sa.addr_type == IEEE802154_ADDR_SHORT) {
+			u16 *sa = &(mac_cb(skb)->sa.short_addr);
+
+			if (mac802154_fetch_skb_u16(skb, sa))
+				goto err;
+
+			pr_debug("source address is short: %04x\n",
+				 mac_cb(skb)->sa.short_addr);
+		} else {
+			if (!pskb_may_pull(skb, IEEE802154_ADDR_LEN))
+				goto err;
+
+			mac802154_haddr_copy_swap(mac_cb(skb)->sa.hwaddr,
+						  skb->data);
+			skb_pull(skb, IEEE802154_ADDR_LEN);
+
+			pr_debug("source address is hardware\n");
+		}
+	}
+
+	return 0;
+err:
+	return -EINVAL;
+}
+
+/*
+ * to bind XBEE RX API frame to a ieee802154_addr
+ * addr_type = IEEE802154_ADDR_LONG (EUI-64 + PanId)
+ * pan_id = network ID (cmd ATID result should be used)
+ * hwaddr = RX EUI-64bit addr from API
+struct ieee802154_addr {
+	int addr_type;
+	u16 pan_id;
+	union {
+		u8 hwaddr[IEEE802154_ADDR_LEN];
+		u16 short_addr;
+	};
+};
+ *
+ */
+
+static int mac802154_header_create(struct sk_buff *skb,
+					struct ieee802154_dev *dev,
+				   unsigned short type,
+				   const void *_daddr,
+				   const void *_saddr,
+				   unsigned len)
+{
+	const struct ieee802154_addr *saddr = _saddr;
+	const struct ieee802154_addr *daddr = _daddr;
+	struct ieee802154_addr dev_addr;
+	struct xbee_device *xbee_dev = dev->priv;
+	int pos = 2;
+	u8 head[MAC802154_FRAME_HARD_HEADER_LEN];
+	u16 fc;
+
+	if (!daddr)
+		return -EINVAL;
+
+	//head[pos++] = mac_cb(skb)->seq; /* DSN/BSN */ /* we should use FrameID here!!!! */
+	//head[pos++] = xbee_get_dsn(dev);
+	head[pos++] = 0;
+	fc = mac_cb_type(skb);
+
+	if (!saddr) {
+		//spin_lock_bh(&zbdev->mib_lock);
+
+//		if (zbdev->short_addr == IEEE802154_ADDR_BROADCAST ||
+//			zbdev->short_addr == IEEE802154_ADDR_UNDEF ||
+//			zbdev->pan_id == IEEE802154_PANID_BROADCAST) {
+			dev_addr.addr_type = IEEE802154_ADDR_LONG;
+//
+			// replace here with EUI64 of the hw
+			memcpy(dev_addr.hwaddr, xbee_dev->dev_addr, IEEE802154_ADDR_LEN);
+//		} else {
+//			dev_addr.addr_type = IEEE802154_ADDR_SHORT;
+//			dev_addr.short_addr = zbdev->short_addr;
+//		}
+
+		dev_addr.pan_id = xbee_dev->pan_id; // network addr ATID?
+		saddr = &dev_addr;
+
+		//spin_unlock_bh(&zbdev->mib_lock);
+	}
+
+	if (daddr->addr_type != IEEE802154_ADDR_NONE) {
+		fc |= (daddr->addr_type << IEEE802154_FC_DAMODE_SHIFT);
+
+		head[pos++] = daddr->pan_id & 0xff;
+		head[pos++] = daddr->pan_id >> 8;
+
+		if (daddr->addr_type == IEEE802154_ADDR_SHORT) {
+			head[pos++] = daddr->short_addr & 0xff;
+			head[pos++] = daddr->short_addr >> 8;
+		} else {
+			mac802154_haddr_copy_swap(head + pos, daddr->hwaddr);
+			pos += IEEE802154_ADDR_LEN;
+		}
+	}
+
+	if (saddr->addr_type != IEEE802154_ADDR_NONE) {
+		fc |= (saddr->addr_type << IEEE802154_FC_SAMODE_SHIFT);
+
+		if ((saddr->pan_id == daddr->pan_id) &&
+		    (saddr->pan_id != IEEE802154_PANID_BROADCAST)) {
+			/* PANID compression/intra PAN */
+			fc |= IEEE802154_FC_INTRA_PAN;
+		} else {
+			head[pos++] = saddr->pan_id & 0xff;
+			head[pos++] = saddr->pan_id >> 8;
+		}
+
+		if (saddr->addr_type == IEEE802154_ADDR_SHORT) {
+			head[pos++] = saddr->short_addr & 0xff;
+			head[pos++] = saddr->short_addr >> 8;
+		} else {
+			mac802154_haddr_copy_swap(head + pos, saddr->hwaddr);
+			pos += IEEE802154_ADDR_LEN;
+		}
+	}
+
+	head[0] = fc;
+	head[1] = fc >> 8;
+
+	memcpy(skb_push(skb, pos), head, pos);
+
+	return pos;
+}
+
+//#define DEBUG 1
+static int enable_debug = 0;
+
+static int
+ieee802154_hm_trp_xmit(struct ieee802154_dev *dev, struct sk_buff *skb){
+	struct xbee_device *xbee_dev = NULL;
+	_api_frame_t *api_frame = NULL;
+
+	struct sk_buff *sskb = NULL;
+	int ret = 0;
+
+	xbee_dev = dev->priv;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return -EINVAL;
+	}
+	pr_debug("%s(): recv_state: %d\n", __func__, xbee_dev->recv_state);
+
+	pr_debug("%s(): BEFORE wait\n", __func__);
+	if (wait_event_interruptible_timeout(xbee_dev->wq,
+				xbee_dev->recv_state == RECV_STATE_WAIT_START_DELIM,
+				msecs_to_jiffies(1000)) > 0) {
+		pr_debug("%s(): AFTER wait\n", __func__);
+	} else {
+		ret = -ETIMEDOUT;
+		pr_debug("%s(): TIMEOUT\n", __func__);
+		goto out;
+	}
+
+	sskb = skb_clone(skb, GFP_ATOMIC);
+	if (sskb) {
+		api_frame = _api_frame_new_raw_packet(xbee_dev,sskb->data,sskb->len);
+
+		if(api_frame){
+			_api_frame_print(api_frame);
+
+			ret = xbee_send(xbee_dev,api_frame);
+			if(ret){
+				ret = -EAGAIN;
+				if(enable_debug){
+					print_hex_dump_bytes("ieee802154_serial_xmit(): before parse: ", DUMP_PREFIX_NONE,sskb->data, sskb->len);
+				}
+			}
+			pr_debug("%s: xbee_send ret: %d\n", __func__,ret);
+			_api_frame_free(api_frame);
+		} else {
+			ret = -ENOMEM;
+			printk(KERN_DEBUG "%s: xbee_send ret: %d\n", __func__,ret);
+		}
+		kfree_skb(sskb);
+	}
+out:
+	pr_debug("%s end\n", __func__);
+	return ret;
+}
+
+static int
+ieee802154_xbee_xmit(struct ieee802154_dev *dev, struct sk_buff *skb){
+	u8 broadcast_check = 0x00;
+	u8 xbee_broadcast_addr[XBEE_ADDR_LEN] = {0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF};
+	struct xbee_device *xbee_dev = NULL;
+	_api_frame_t *api_frame = NULL;
+
+	struct sk_buff *sskb = NULL;
+	int ret = 0;
+
+	xbee_dev = dev->priv;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return -EINVAL;
+	}
+	pr_debug("%s(): recv_state: %d\n", __func__, xbee_dev->recv_state);
+
+	pr_debug("%s(): BEFORE wait\n", __func__);
+	if (wait_event_interruptible_timeout(xbee_dev->wq,
+				xbee_dev->recv_state == RECV_STATE_WAIT_START_DELIM,
+				msecs_to_jiffies(1000)) > 0) {
+		pr_debug("%s(): AFTER wait\n", __func__);
+	} else {
+		ret = -ETIMEDOUT;
+		pr_debug("%s(): TIMEOUT\n", __func__);
+		goto out;
+	}
+
+	sskb = skb_clone(skb, GFP_ATOMIC);
+	if (sskb) {
+
+#ifdef DEBUG
+		print_hex_dump_bytes("ieee802154_serial_xmit(): before parse: ", DUMP_PREFIX_NONE,
+				skb->data, skb->len);
+#endif
+		mac802154_parse_frame_start(sskb);
+		pr_debug("%s(): type: %d\n", __func__, sskb->pkt_type);
+		pr_debug("%s(): mac_len: %d\n", __func__, sskb->mac_len);
+		pr_debug("%s(): len: %d\n", __func__, sskb->len);
+#ifdef DEBUG
+		print_hex_dump_bytes("ieee802154_serial_xmit(): mac_header: ", DUMP_PREFIX_NONE,
+				sskb->mac_header, sskb->mac_len);
+#endif
+
+		pr_debug("%s(): sa.addr_type: %d\n", __func__, mac_cb(sskb)->sa.addr_type);
+#ifdef DEBUG
+		print_hex_dump_bytes("ieee802154_serial_xmit(): sa.hwaddr: ", DUMP_PREFIX_NONE,
+				mac_cb(sskb)->sa.hwaddr, 8);
+#endif
+		pr_debug("%s(): da.addr_type: %d\n", __func__, mac_cb(sskb)->da.addr_type);
+#ifdef DEBUG
+		print_hex_dump_bytes("ieee802154_serial_xmit(): da.hwaddr: ", DUMP_PREFIX_NONE,
+				mac_cb(sskb)->da.hwaddr, 8);
+#endif
+#ifdef DEBUG
+		print_hex_dump_bytes("ieee802154_serial_xmit(): data: ", DUMP_PREFIX_NONE,
+				sskb->data, sskb->len);
+#endif
+
+		/*
+		 * check if da.hwaddr is broadcast (0xFFFFFFFFFFFFFFFF) and
+		 * ERRATA: check if da.hwaddr is broadcast (0xFFFF0000000000) and
+		 * replace with 0x000000000000FFFF
+		 */
+		if(mac_cb(sskb)->da.hwaddr[0] == 0xFF &&
+				mac_cb(sskb)->da.hwaddr[1] == 0xFF &&
+				mac_cb(sskb)->da.hwaddr[2] == 0x00 &&
+				mac_cb(sskb)->da.hwaddr[3] == 0x00 &&
+				mac_cb(sskb)->da.hwaddr[4] == 0x00 &&
+				mac_cb(sskb)->da.hwaddr[5] == 0x00 &&
+				mac_cb(sskb)->da.hwaddr[6] == 0x00 &&
+				mac_cb(sskb)->da.hwaddr[7] == 0x00
+				){
+			broadcast_check = 0xFF;
+		}
+		if(broadcast_check == 0xFF){
+			api_frame = _api_frame_new_transmit_request(xbee_dev,xbee_broadcast_addr,0x00,skb->data,skb->len);
+			//api_frame = _api_frame_new_transmit_request_splited(xbee_dev,xbee_broadcast_addr,0x00,sskb->data,sskb->len);
+		} else {
+			api_frame = _api_frame_new_transmit_request(xbee_dev,xbee_broadcast_addr,0x00,skb->data,skb->len);
+			//api_frame = _api_frame_new_transmit_request_splited(xbee_dev,mac_cb(sskb)->da.hwaddr,0x00,sskb->data,sskb->len);
+		}
+
+		if(api_frame){
+			_api_frame_print(api_frame);
+
+			ret = xbee_send(xbee_dev,api_frame);
+			if(ret){
+				ret = -EAGAIN;
+				if(enable_debug){
+					print_hex_dump_bytes("ieee802154_serial_xmit(): before parse: ", DUMP_PREFIX_NONE,skb->data, skb->len);
+					pr_debug("%s(): type: %d\n", __func__, sskb->pkt_type);
+					pr_debug("%s(): mac_len: %d\n", __func__, sskb->mac_len);
+					pr_debug("%s(): len: %d\n", __func__, sskb->len);
+					print_hex_dump_bytes("ieee802154_serial_xmit(): mac_header: ", DUMP_PREFIX_NONE,
+							sskb->mac_header, sskb->mac_len);
+					printk(KERN_DEBUG "%s(): sa.addr_type: %d\n", __func__, mac_cb(sskb)->sa.addr_type);
+					print_hex_dump_bytes("ieee802154_serial_xmit(): sa.hwaddr: ", DUMP_PREFIX_NONE,
+							mac_cb(sskb)->sa.hwaddr, 8);
+					printk(KERN_DEBUG "%s(): da.addr_type: %d\n", __func__, mac_cb(sskb)->da.addr_type);
+					print_hex_dump_bytes("ieee802154_serial_xmit(): da.hwaddr: ", DUMP_PREFIX_NONE,
+							mac_cb(sskb)->da.hwaddr, 8);
+					print_hex_dump_bytes("ieee802154_serial_xmit(): data: ", DUMP_PREFIX_NONE,
+							sskb->data, sskb->len);
+				}
+
+			}
+			pr_debug("%s: xbee_send ret: %d\n", __func__,ret);
+			_api_frame_free(api_frame);
+		} else {
+			ret = -ENOMEM;
+			printk(KERN_DEBUG "%s: xbee_send ret: %d\n", __func__,ret);
+		}
+		kfree_skb(sskb);
+	}
+out:
+	pr_debug("%s end\n", __func__);
+	return ret;
+}
+
+static int
+ieee802154_xmit(struct ieee802154_dev *dev, struct sk_buff *skb){
+	struct xbee_device *xbee_dev = NULL;
+	int ret = 0;
+	int mote_type = UNKNOWN_MOTE;
+	xbee_dev = dev->priv;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return -EINVAL;
+	}
+
+	mote_type = xbee_device_get_type(xbee_dev);
+
+	switch(mote_type){
+	case XBEE_XB08_DP_MOTE:
+		ret = ieee802154_xbee_xmit(dev,skb);
+		break;
+	case HM_TRP_433D_MOTE:
+	case HM_TRP_868D_MOTE:
+		ret = ieee802154_hm_trp_xmit(dev,skb);
+		break;
+	default:
+		ret = -ENOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+static int
+ieee802154_xbee_ed(struct ieee802154_dev *dev, u8 *level){
+	int ret = 0;
+	int mote_type = UNKNOWN_MOTE;
+	struct xbee_device *xbee_dev = NULL;
+	pr_debug("%s\n", __func__);
+
+	xbee_dev = dev->priv;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return -EINVAL;
+	}
+
+	mote_type = xbee_device_get_type(xbee_dev);
+	printk(KERN_DEBUG "%s: mote type: %d\n", __func__,mote_type);
+
+	pr_debug("%s end\n", __func__);
+	return ret;
+}
+
+static int
+ieee802154_xbee_set_channel(struct ieee802154_dev *dev, int page, int channel){
+	int ret = 0;
+	struct xbee_device *xbee_dev = NULL;
+	int mote_type = UNKNOWN_MOTE;
+	pr_debug("%s\n", __func__);
+
+	xbee_dev = dev->priv;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return -EINVAL;
+	}
+
+	mote_type = xbee_device_get_type(xbee_dev);
+	printk(KERN_DEBUG "%s: mote type: %d\n", __func__,mote_type);
+
+	pr_debug("%s end\n", __func__);
+	return ret;
+}
+
+static int
+ieee802154_xbee_start(struct ieee802154_dev *dev){
+	int ret = 0;
+	struct xbee_device *xbee_dev = NULL;
+	int mote_type = UNKNOWN_MOTE;
+	pr_debug("%s\n", __func__);
+	xbee_dev = dev->priv;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return -EINVAL;
+	}
+
+	mote_type = xbee_device_get_type(xbee_dev);
+	printk(KERN_DEBUG "%s: mote type: %d\n", __func__,mote_type);
+
+	pr_debug("%s end\n", __func__);
+	return ret;
+}
+
+static void
+ieee802154_xbee_stop(struct ieee802154_dev *dev){
+	//struct xbee_device *xbee_dev = NULL;
+	pr_debug("%s\n", __func__);
+	pr_debug("%s end\n", __func__);
+	return;
+}
+
+static int
+ieee802154_xbee_address(struct ieee802154_dev *dev, u8 addr[IEEE802154_ADDR_LEN]){
+	int ret = 0;
+	struct xbee_device *xbee_dev = NULL;
+	int mote_type = UNKNOWN_MOTE;
+	u8 addr_tmp[IEEE802154_ADDR_LEN] = {};
+	u8 network_id[2] = {};
+
+	pr_debug("%s\n", __func__);
+
+	xbee_dev = dev->priv;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return -EINVAL;
+	}
+
+	mote_type = xbee_device_get_type(xbee_dev);
+	printk(KERN_DEBUG "%s: mote type: %d\n", __func__,mote_type);
+
+	ret = xbee_api_at_command_read_u32(xbee_dev,"SH",addr_tmp);
+	if(ret)
+	{
+		printk(KERN_ERR "%s: error getting serial high value\n", __func__);
+		return ret;
+	}
+	ret = xbee_api_at_command_read_u32(xbee_dev,"SL",addr_tmp+4);
+	if(ret)
+	{
+		printk(KERN_ERR "%s: error getting serial low value\n", __func__);
+		return ret;
+	}
+	memcpy(addr,addr_tmp,IEEE802154_ADDR_LEN);
+	memcpy(xbee_dev->dev_addr,addr_tmp,IEEE802154_ADDR_LEN);
+
+	ret = xbee_api_at_command_read_u16(xbee_dev,"ID",network_id);
+	if(ret)
+	{
+		printk(KERN_ERR "%s: error getting serial low value\n", __func__);
+		return ret;
+	}
+	xbee_dev->pan_id = ((network_id[0] << 8) & 0xFF00) + (network_id[1] & 0xFF);
+
+	pr_debug("%s end\n", __func__);
+	return ret;
+}
+
+/*
+ * to bind XBEE RX API frame to a ieee802154_addr
+ * addr_type = IEEE802154_ADDR_LONG (EUI-64 + PanId)
+ * pan_id = network ID (cmd ATID result should be used)
+ * hwaddr = RX EUI-64bit addr from API
+struct ieee802154_addr {
+	int addr_type;
+	u16 pan_id;
+	union {
+		u8 hwaddr[IEEE802154_ADDR_LEN];
+		u16 short_addr;
+	};
+};
+ *
+ */
+
+struct xbee_rx_work {
+	struct sk_buff *skb;
+	struct work_struct work;
+	struct xbee_device *xbee_dev;
+	uint8_t lqi;
+	bool update_lqi;
+	u8 src_addr[IEEE802154_ADDR_LEN];
+};
+
+static void xbee_rx_worker(struct work_struct *work)
+{
+	u8 lqi = 0x00;
+	struct xbee_rx_work *rw = container_of(work, struct xbee_rx_work, work);
+	struct sk_buff *skb = rw->skb;
+
+	if(rw->xbee_dev->device_driver == HM_TRP_433D_MOTE || rw->xbee_dev->device_driver == HM_TRP_868D_MOTE){
+		lqi = rw->lqi;
+	}else if(rw->xbee_dev->device_driver == XBEE_XB08_DP_MOTE){
+		lqi = xbee_get_rssi(rw->xbee_dev->dev);
+		pr_debug("%s(): lqi: %d (0x%02X)\n", __func__,lqi,lqi);
+	}
+	ieee802154_rx_irqsafe(rw->xbee_dev->dev, skb, lqi);
+	if(rw->update_lqi)
+		xbee_stat_update_lqi(rw->src_addr,lqi);
+	kfree(rw);
+}
+
+//static void
+//xbee_net_rx_old(struct xbee_device *xbee_dev, _api_frame_t *api_frame){
+//	/* zbdev->param1 is LQI
+//	 * zbdev->param2 is length of data
+//	 * zbdev->data is data itself
+//	 */
+//	struct sk_buff *skb = NULL;
+//	unsigned char *data = NULL;
+////	struct ieee802154_addr saddr = {};
+////	struct ieee802154_addr daddr = {};
+//
+//	struct xbee_rx_work *work;
+//
+//	skb = alloc_skb(api_frame->api_data->receive_packet.payload_len, GFP_ATOMIC);
+////	skb_reserve(skb,MAC802154_FRAME_HARD_HEADER_LEN);
+//
+//	data = skb_put(skb, api_frame->api_data->receive_packet.payload_len);
+//	//skb_copy_to_linear_data(skb, api_frame->api_data->receive_packet.payload, api_frame->api_data->receive_packet.payload_len);
+//	//memcpy(skb->data, from, len);
+//	memcpy(data, api_frame->api_data->receive_packet.payload, api_frame->api_data->receive_packet.payload_len);
+//
+////	saddr.addr_type = IEEE802154_ADDR_LONG;
+////	//saddr.pan_id = xbee_dev->pan_id;
+////	saddr.pan_id = 0x00FF;
+////	memcpy(saddr.hwaddr,api_frame->api_data->receive_packet.src_addr,IEEE802154_ADDR_LEN);
+////
+////	daddr.addr_type = IEEE802154_ADDR_LONG;
+////	//daddr.pan_id = xbee_dev->pan_id;
+////	daddr.pan_id = 0x00FF;
+////	memcpy(daddr.hwaddr,xbee_dev->dev_addr,IEEE802154_ADDR_LEN);
+////
+////	mac_cb(skb)->flags = IEEE802154_FC_TYPE_DATA;
+////	mac802154_header_create(skb,xbee_dev->dev,0,&daddr,&saddr,0);
+//
+//	pr_debug("%s(): type: %d\n", __func__, skb->pkt_type);
+//#ifdef DEBUG
+//	//print_hex_dump_bytes("xbee_net_rx(): ", DUMP_PREFIX_NONE, skb->data, skb->len);
+//	print_hex_dump_bytes("xbee_net_rx(): ", DUMP_PREFIX_NONE, data, skb->len);
+//#endif
+//
+//	//skb_trim(skb, api_frame->api_data->receive_packet.payload_len - 2); /* We do not put CRC into the frame */
+//
+//	work = kzalloc(sizeof(struct xbee_rx_work), GFP_ATOMIC);
+//	if (!work)
+//	{
+//		kfree_skb(skb);
+//		return;
+//	}
+//
+//	INIT_WORK(&work->work, xbee_rx_worker);
+//	work->skb = skb;
+//	work->xbee_dev = xbee_dev;
+//	memcpy(work->src_addr,api_frame->api_data->receive_packet.src_addr,IEEE802154_ADDR_LEN);
+//
+//	queue_work(xbee_dev->frames_workqueue, &work->work);
+//}
+
+static void
+hm_trp_rx(struct xbee_device *xbee_dev, _api_frame_t *api_frame){
+	/* zbdev->param1 is LQI
+	 * zbdev->param2 is length of data
+	 * zbdev->data is data itself
+	 */
+	struct sk_buff *skb = NULL;
+	unsigned char *data = NULL;
+	struct xbee_rx_work *work;
+
+	skb = alloc_skb(api_frame->api_data->raw_packet.payload_len, GFP_ATOMIC);
+
+	data = skb_put(skb, api_frame->api_data->raw_packet.payload_len);
+	memcpy(data, api_frame->api_data->raw_packet.payload, api_frame->api_data->raw_packet.payload_len);
+
+	pr_debug("%s(): type: %d\n", __func__, skb->pkt_type);
+#ifdef DEBUG
+	print_hex_dump_bytes("hm_trp_net_rx(): ", DUMP_PREFIX_NONE, data, skb->len);
+#endif
+
+	work = kzalloc(sizeof(struct xbee_rx_work), GFP_ATOMIC);
+	if (!work)
+	{
+		kfree_skb(skb);
+		return;
+	}
+
+	INIT_WORK(&work->work, xbee_rx_worker);
+	work->skb = skb;
+	work->xbee_dev = xbee_dev;
+	work->update_lqi = false;							// FIXME: THERE'S still MISSING TO SET SOURCE ADDRESS. IT MUST BE EXTRACTED FROM PACKET
+	work->lqi = api_frame->api_data->raw_packet.lqi;
+	queue_work(xbee_dev->frames_workqueue, &work->work);
+}
+
+static void
+xbee_rx(struct xbee_device *xbee_dev, _api_frame_t *api_frame){
+	/* zbdev->param1 is LQI
+	 * zbdev->param2 is length of data
+	 * zbdev->data is data itself
+	 */
+	struct sk_buff *skb = NULL;
+	unsigned char *data = NULL;
+	struct xbee_rx_work *work;
+
+	skb = alloc_skb(api_frame->api_data->receive_packet.payload_len, GFP_ATOMIC);
+
+	data = skb_put(skb, api_frame->api_data->receive_packet.payload_len);
+	memcpy(data, api_frame->api_data->receive_packet.payload, api_frame->api_data->receive_packet.payload_len);
+
+#ifdef DEBUG
+	//print_hex_dump_bytes("xbee_net_rx(): ", DUMP_PREFIX_NONE, skb->data, skb->len);
+	print_hex_dump_bytes("xbee_net_rx(): ", DUMP_PREFIX_NONE, data, skb->len);
+#endif
+
+	work = kzalloc(sizeof(struct xbee_rx_work), GFP_ATOMIC);
+	if (!work)
+	{
+		kfree_skb(skb);
+		return;
+	}
+
+	INIT_WORK(&work->work, xbee_rx_worker);
+	work->skb = skb;
+	work->xbee_dev = xbee_dev;
+	work->update_lqi = true;
+	memcpy(work->src_addr,api_frame->api_data->receive_packet.src_addr,IEEE802154_ADDR_LEN);
+	queue_work(xbee_dev->frames_workqueue, &work->work);
+}
+
+static void
+ieee802154_net_rx(struct xbee_device *xbee_dev, _api_frame_t *api_frame){
+	int mote_type = UNKNOWN_MOTE;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s: wrong phy\n", __func__);
+		return;
+	}
+	mote_type = xbee_device_get_type(xbee_dev);
+	switch(mote_type){
+	case XBEE_XB08_DP_MOTE:
+		xbee_rx(xbee_dev,api_frame);
+		break;
+	case HM_TRP_433D_MOTE:
+	case HM_TRP_868D_MOTE:
+		hm_trp_rx(xbee_dev,api_frame);
+		break;
+	default:
+		break;
+	}
+}
+
+/*****************************************************************************
+ * Line discipline interface for IEEE 802.15.4 serial device
+ *****************************************************************************/
+
+static struct ieee802154_ops serial_ops = {
+	.owner = THIS_MODULE,
+	.xmit		= ieee802154_xmit,
+	.ed			= ieee802154_xbee_ed,
+	.set_channel	= ieee802154_xbee_set_channel,
+	.start		= ieee802154_xbee_start,
+	.stop		= ieee802154_xbee_stop,
+	.ieee_addr	= ieee802154_xbee_address,
+};
+
+/*
+ * The "foo" file where a static variable is read from and written to.
+ */
+
+static ssize_t debug_show(struct kobject *kobj, struct kobj_attribute *attr,
+		char *buf) {
+	return sprintf(buf, "%d\n", enable_debug);
+}
+
+static ssize_t debug_store(struct kobject *kobj, struct kobj_attribute *attr,
+		const char *buf, size_t count) {
+	sscanf(buf, "%d", &enable_debug);
+	return count;
+}
+
+static struct kobj_attribute debug_attribute = __ATTR(debug, 0666, debug_show, debug_store);
+
+/*
+ * The "foo" file where a static variable is read from and written to.
+ */
+static ssize_t lqi_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf) {
+	//return sprintf(buf, "%d\n", global_lqi);
+	return xbee_stat_get_lqi_table(buf);
+}
+
+static ssize_t lqi_store(struct kobject *kobj, struct kobj_attribute *attr,
+		const char *buf, size_t count) {
+	return count;
+}
+
+static struct kobj_attribute lqi_attribute = __ATTR(lqi, 0666, lqi_show, lqi_store);
+
+/*
+ * Create a group of attributes so that we can create and destory them all
+ * at once.
+ */
+static struct attribute *attrs[] = {
+		&lqi_attribute.attr,
+		&debug_attribute.attr,
+		NULL , /* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory.  If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+static struct attribute_group attr_group = { .attrs = attrs, };
+
+static struct kobject *xbee_kobj;
+
+/*
+ * Called when a tty is put into ZB line discipline. Called in process context.
+ * Returns 0 on success.
+ */
+static int
+ieee802154_tty_open(struct tty_struct *tty)
+{
+	struct xbee_device *xbee_dev = tty->disc_data;
+	struct ieee802154_dev *dev;
+	int err;
+	int retval;
+
+	pr_debug("Openning ldisc\n");
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (tty->disc_data)
+		return -EBUSY;
+
+	dev = ieee802154_alloc_device(sizeof(*xbee_dev), &serial_ops);
+	if (!dev)
+		return -ENOMEM;
+
+	xbee_dev = dev->priv;
+	xbee_dev->dev = dev;
+
+	xbee_dev->device_driver = UNKNOWN_MOTE;
+
+	xbee_dev->escaped_mode = 1;
+	xbee_dev->frame_id_counter = 1;
+	xbee_dev->recv_state = RECV_STATE_WAIT_START_DELIM;
+
+	mutex_init(&xbee_dev->mutex);
+	init_waitqueue_head(&xbee_dev->wq);
+
+	dev->extra_tx_headroom = 0;
+	/* only 2.4 GHz band */
+	dev->phy->channels_supported[0] = 0x7fff800;
+
+	dev->flags = IEEE802154_HW_OMIT_CKSUM|IEEE802154_HW_AACK;
+
+	dev->parent = tty->dev;
+
+	xbee_dev->tty = tty_kref_get(tty);
+
+	tty->disc_data = xbee_dev;
+	tty->receive_room = MAX_DATA_SIZE;
+
+	/* FIXME: why is this needed. Note don't use ldisc_ref here as the
+	   open path is before the ldisc is referencable */
+
+	if (tty->ldisc->ops->flush_buffer)
+		tty->ldisc->ops->flush_buffer(tty);
+	tty_driver_flush_buffer(tty);
+
+	err = ieee802154_register_device(dev);
+	if (err) {
+		printk(KERN_ERR "%s: device register failed\n", __func__);
+		goto out_free;
+	}
+
+	xbee_dev->frames_workqueue =
+		create_singlethread_workqueue(wpan_phy_name(xbee_dev->dev->phy));
+	if (!xbee_dev->frames_workqueue)
+		goto out_unregister;
+
+	/*
+	 * Create a simple kobject with the name of "kobject_example",
+	 * located under /sys/kernel/
+	 *
+	 * As this is a simple directory, no uevent will be sent to
+	 * userspace.  That is why this function should not be used for
+	 * any type of dynamic kobjects, where the name and number are
+	 * not known ahead of time.
+	 */
+	xbee_kobj = kobject_create_and_add("xbee", kernel_kobj);
+	if (!xbee_kobj)
+		return -ENOMEM;
+
+	/* Create the files associated with this kobject */
+	retval = sysfs_create_group(xbee_kobj, &attr_group);
+	if (retval)
+		kobject_put(xbee_kobj);
+
+	return 0;
+
+out_unregister:
+	ieee802154_unregister_device(xbee_dev->dev);
+
+out_free:
+	destroy_workqueue(xbee_dev->frames_workqueue);
+	tty->disc_data = NULL;
+	tty_kref_put(tty);
+	xbee_dev->tty = NULL;
+
+	ieee802154_free_device(xbee_dev->dev);
+
+	return err;
+}
+
+/*
+ * Called when the tty is put into another line discipline or it hangs up. We
+ * have to wait for any cpu currently executing in any of the other zb_tty_*
+ * routines to finish before we can call zb_tty_close and free the
+ * zb_serial_dev struct. This routine must be called from process context, not
+ * interrupt or softirq context.
+ */
+static void
+ieee802154_tty_close(struct tty_struct *tty)
+{
+	struct xbee_device *xbee_dev;
+
+	xbee_dev = tty->disc_data;
+	if (NULL == xbee_dev) {
+		printk(KERN_WARNING "%s: match is not found\n", __func__);
+		return;
+	}
+
+	flush_workqueue(xbee_dev->frames_workqueue);
+	destroy_workqueue(xbee_dev->frames_workqueue);
+
+	tty->disc_data = NULL;
+	tty_kref_put(tty);
+	xbee_dev->tty = NULL;
+
+	ieee802154_unregister_device(xbee_dev->dev);
+
+	tty_ldisc_flush(tty);
+	tty_driver_flush_buffer(tty);
+
+	ieee802154_free_device(xbee_dev->dev);
+
+	kobject_put(xbee_kobj);
+}
+
+/*
+ * Called on tty hangup in process context.
+ */
+static int
+ieee802154_tty_hangup(struct tty_struct *tty)
+{
+	ieee802154_tty_close(tty);
+	return 0;
+}
+
+/*
+ * Called in process context only. May be re-entered
+ * by multiple ioctl calling threads.
+ */
+static int
+ieee802154_tty_ioctl(struct tty_struct *tty, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	struct xbee_device *xbee_dev;
+
+	pr_debug("cmd = 0x%x\n", cmd);
+
+	xbee_dev = tty->disc_data;
+	if (NULL == xbee_dev) {
+		pr_debug("match is not found\n");
+		return -EINVAL;
+	}
+
+	switch (cmd) {
+	case TCFLSH:
+		return tty_perform_flush(tty, arg);
+	default:
+		/* Try the mode commands */
+		return tty_mode_ioctl(tty, file, cmd, arg);
+	}
+}
+
+
+/*
+ * This can now be called from hard interrupt level as well
+ * as soft interrupt level or mainline.
+ */
+static void
+ieee802154_tty_receive(struct tty_struct *tty, const unsigned char *buf,
+		char *cflags, int count)
+{
+	struct xbee_device *xbee_dev;
+//	int i = 0;
+
+	/* Debug info */
+#ifdef DEBUG
+	printk(KERN_INFO "%s, received %d bytes\n", __func__,
+			count);
+	print_hex_dump_bytes("ieee802154_tty_receive ", DUMP_PREFIX_NONE,
+			buf, count);
+#endif
+
+	/* Actual processing */
+	xbee_dev = tty->disc_data;
+	if (NULL == xbee_dev) {
+		printk(KERN_ERR "%s(): record for tty is not found\n",
+				__func__);
+		return;
+	}
+
+	xbee_receive(xbee_dev,buf,count);
+
+//out:
+	tty_unthrottle(tty);
+}
+
+/*
+ * Line discipline device structure
+ */
+static struct tty_ldisc_ops xbee_ldisc = {
+	.owner  = THIS_MODULE,
+	.magic	= TTY_LDISC_MAGIC,
+	.name	= "ieee802154-ldisc",
+	.open	= ieee802154_tty_open,
+	.close	= ieee802154_tty_close,
+	.hangup	= ieee802154_tty_hangup,
+	.receive_buf = ieee802154_tty_receive,
+	.ioctl	= ieee802154_tty_ioctl,
+};
+
+/*****************************************************************************
+ * Module service routinues
+ *****************************************************************************/
+
+static int __init ieee802154_xbee_init(void)
+{
+	printk(KERN_INFO "Initializing XBee/HM-TRP TTY for Xbee RF 868 OEM and HM-TRP interface\n");
+
+	xbee_stats_init();
+
+	if (tty_register_ldisc(N_IEEE802154, &xbee_ldisc) != 0) {
+		printk(KERN_ERR "%s: line discipline register failed\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void __exit ieee802154_xbee_cleanup(void)
+{
+	xbee_stats_tini();
+	if (tty_unregister_ldisc(N_IEEE802154) != 0)
+		printk(KERN_CRIT
+			"failed to unregister XBee line discipline.\n");
+}
+
+module_init(ieee802154_xbee_init);
+module_exit(ieee802154_xbee_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("João Pedro Taveira");
+MODULE_AUTHOR("Martijn Kuipers");
+MODULE_ALIAS_LDISC(N_IEEE802154);
+
+#endif /* __KERNEL__ */
+
+#ifndef __KERNEL__
+uint8_t ex36esc[] = {0x7E,0x00,0x02,0x23,0x7D,0x31,0xCB};
+uint8_t exTR40esc[] = {0x7E,0x00,0x16,0x10,0x01,0x00,0x7D,0x33,0xA2,0x00,0x40,0x0A,0x01,0x27,0xFF,0xFE,0x00,0x00,0x54,0x78,0x44,0x61,0x74,0x61,0x30,0x41,0x7D,0x33};
+
+uint8_t ex36escexTR40esc[] = {0x7E,0x00,0x02,0x23,0x7D,0x31,0xCB,0x7E,0x00,0x16,0x10,0x01,0x00,0x7D,0x33,0xA2,0x00,0x40,0x0A,0x01,0x27,0xFF,0xFE,0x00,0x00,0x54,0x78,0x44,0x61,0x74,0x61,0x30,0x41,0x7D,0x33};
+
+uint8_t exTR40escError[] = {0x7E,0x00,0x16,0x10,0x01,0x00,0x7D,0x33,0x7E,0x00,0x02,0x23,0x7D,0x31,0xCB,0xA2,0x00,0x40,0x0A,0x01,0x27,0xFF,0xFE,0x00,0x00,0x54,0x78,0x44,0x61,0x74,0x61,0x30,0x41,0x7D,0x33,0x7E,0x00,0x16,0x10,0x01,0x00,0x7D,0x33,0xA2,0x00,0x40,0x0A,0x01,0x27,0xFF,0xFE,0x00,0x00,0x54,0x78,0x44,0x61,0x74,0x61,0x30,0x41,0x7D,0x33};
+
+uint8_t teste2[] = {0x7E,0x00,0x08,0x08,0x03,0x42,0x44,0xAA,0xBB,0xCC,0xDD,0x60};
+
+uint8_t receive_packet[] = {0x7E,0x00,0x13,0x90,0x00,0x00,0x13,0xA2,0x00,0x40,0x52,0x2B,0xAA,0xFF,0xFE,0x01,0x52,0x78,0x44,0x61,0x74,0x61,0x11};
+
+uint8_t at_cmd_response_BD[] = {0x7E,0x00,0x05,0x88,0x01,0x42,0x44,0x00,0xF0};
+
+uint8_t at_cmd_response_SH[] = {0x7E,0x00,0x09,0x88,0x02,0x53,0x48,0x00,0xAA,0xBB,0xCC,0xDD,0xCC};
+uint8_t at_cmd_response_SL[] = {0x7E,0x00,0x09,0x88,0x03,0x53,0x4C,0x00,0x11,0x22,0x33,0x44,0x2B};
+
+uint8_t modem_status_hw_reset[] = {0x7E,0x00,0x02,0x8A,0x00,0x75};
+uint8_t modem_status_timer_reset[] = {0x7E,0x00,0x02,0x8A,0x01,0x74};
+uint8_t modem_status_net_woke_up[] = {0x7E,0x00,0x02,0x8A,0x0B,0x6A};
+uint8_t modem_status_net_went2sleep[] = {0x7E,0x00,0x02,0x8A,0x0C,0x69};
+
+uint8_t transmit_status[] = {0x7E,0x00,0x07,0x8B,0x47,0xFF,0xFE,0x00,0x00,0x02,0x2E};
+
+//uint8_t transmit_status2[] = {0x7E,0x00,0x07,0x8B,0x01,0xFF,0xFE,0x00,0x00,0x00,0x76};
+
+uint8_t remote_at_command_resp[] = {0x7E,0x00,0x13,0x97,0x55,0x00,0x13,0xA2,0x00,0x40,0x52,0x2B,0xAA,0xFF,0xFE,0x53,0x4C,0x00,0x40,0x52,0x2B,0xAA,0xF4};
+
+uint8_t node_id_indicator[] = {
+		0x7E,
+		0x00,0x1A,
+		0x95, //1
+		0x00,0x13,0xA2,0x00,0x40,0x52,0x2B,0xAA, // 8
+		0x7D,0x7D^0x20,0x84, // 2
+		0x02, // 1
+		0x7D,0x7D^0x20,0x84, // 2
+		0x00,0x13,0xA2,0x00,0x40,0x52,0x2B,0xAA, // 8
+		0x20,0x00, // 2
+		0xFF,0xFE, // 2
+		0x11};
+
+uint8_t explicit_rx_indicator[] = {
+	0x7E,
+	0x00,0x18,
+	0x91,
+	0x00,0x13,0xA2,0x00,0x40,0x52,0x2B,0xAA, // 8
+	0xFF,0xFE,
+	0xE0,
+	0xE0,
+	0x22,0x11,
+	0xC1,0x05,
+	0x02,
+	0x52,0x78,0x44,0x61,0x74,0x61,
+	0x56
+};
+
+
+/*
+ * xbee rx thread
+ */
+
+void xbee_rx_sighandler(int sig){
+	printk(KERN_DEBUG "%s(): signal caught\n",__func__);
+}
+
+void xbee_rx_setup_signals(){
+	printk(KERN_DEBUG "%s(): called\n",__func__);
+	struct sigaction act;
+	act.sa_handler = xbee_rx_sighandler;
+	act.sa_flags = 0;
+	sigemptyset(&act.sa_mask);
+	sigaddset(&act.sa_mask, SIGINT);
+	sigaddset(&act.sa_mask, SIGQUIT);
+	sigaddset(&act.sa_mask, SIGTERM);
+	sigaction(SIGINT,&act,NULL);
+	sigaction(SIGQUIT,&act,NULL);
+	sigaction(SIGTERM,&act,NULL);
+
+	struct sigaction act_pipe;
+	act_pipe.sa_handler = xbee_rx_sighandler;
+	act_pipe.sa_flags = 0;
+	sigemptyset(&act_pipe.sa_mask);
+	sigaddset(&act_pipe.sa_mask, SIGPIPE);
+	sigaction(SIGPIPE,&act_pipe,NULL);
+}
+
+static void
+dump_hex(uint8_t *buf, int len)
+{
+	int i = 0;
+	uint8_t raw_byte = 0;
+	unsigned char *data = (unsigned char *) buf;
+	for(i = 0;i<len;i++){
+		raw_byte = ((unsigned char)*(data+i));
+		printf("%02X ",raw_byte);
+	}
+	printf("\n");
+}
+
+#define XBEE_MAX_RX_LEN 256
+static void *
+xbee_rx_thread(void *data)
+{
+	int recv_len = 0;
+	uint8_t rx_buffer[XBEE_MAX_RX_LEN] = {};
+
+	int running = 1;
+	int end = 0;
+	struct xbee_device *xbee_dev = (struct xbee_device *) data;
+	xbee_rx_setup_signals();
+	printk(KERN_DEBUG "%s(): begin\n", __func__);
+	pthread_mutex_lock(&xbee_dev->mutex);
+	running = xbee_dev->rx_thread_running = 1;
+	end = xbee_dev->rx_thread_end;
+	pthread_mutex_unlock(&xbee_dev->mutex);
+
+	while(running && !end)
+	{
+		fd_set fds;
+		FD_ZERO(&fds);
+		FD_SET(xbee_dev->tty_fd,&fds);
+		struct timeval tv = {1,0};
+		switch(select(xbee_dev->tty_fd+1,&fds,NULL,NULL,&tv)){
+		case 0:
+			printk(KERN_DEBUG "%s: timeout.. waiting again\n",__func__);
+			break;
+		case -1:
+			printk(KERN_ERR "%s(): some error occur in select: %s\n",__func__,strerror(errno));
+			break;
+		default:
+			if(FD_ISSET(xbee_dev->tty_fd,&fds)){
+				recv_len = read(xbee_dev->tty_fd,rx_buffer,XBEE_MAX_RX_LEN);
+				printk(KERN_DEBUG "%s: some activity in tty: %d bytes read\n",__func__,recv_len);
+				dump_hex(rx_buffer, recv_len);
+				xbee_receive(xbee_dev,rx_buffer,recv_len);
+			}
+		}
+		pthread_mutex_lock(&xbee_dev->mutex);
+		running = xbee_dev->rx_thread_running;
+		end = xbee_dev->rx_thread_end;
+		pthread_mutex_unlock(&xbee_dev->mutex);
+	}
+
+	printk(KERN_DEBUG "%s: end\n", __func__);
+	pthread_exit(NULL);
+	return NULL;
+}
+
+static int
+xbee_start_rx_thread(struct xbee_device *xbee_dev){
+	pthread_attr_t attr;
+	pthread_attr_init(&attr);
+	if(xbee_dev == NULL){
+		printk(KERN_ERR "%s(): dev is NULL\n",__func__);
+		return -1;
+	}
+	xbee_rx_setup_signals();
+	printk(KERN_DEBUG "%s(): starting thread\n",__func__);
+	pthread_mutex_lock(&xbee_dev->mutex);
+	if(!xbee_dev->rx_thread_running){
+		xbee_dev->rx_thread_running = 1;
+		xbee_dev->rx_thread_end = 0;
+		if(pthread_create(&xbee_dev->rx_thread_tid,&attr,xbee_rx_thread,xbee_dev)!= 0) {
+			pthread_mutex_unlock(&xbee_dev->mutex);
+			printk(KERN_ERR "%s(): error launching thread\n",__func__);
+			return -1;
+		}
+		printk(KERN_DEBUG "%s(): thread started\n",__func__);
+	} else {
+		printk(KERN_WARNING "%s(): thread already running\n",__func__);
+	}
+	pthread_mutex_unlock(&xbee_dev->mutex);
+	return 1;
+}
+
+static int
+xbee_stop_rx_thread(struct xbee_device *xbee_dev){
+	if(xbee_dev == NULL){
+		printk(KERN_ERR "%s(): dev is NULL\n",__func__);
+		return -1;
+	}
+	pthread_mutex_lock(&xbee_dev->mutex);
+	xbee_dev->rx_thread_running = 0;
+	xbee_dev->rx_thread_end = 1;
+	pthread_mutex_unlock(&xbee_dev->mutex);
+	printk(KERN_DEBUG "%s(): waiting for rx thread to end\n",__func__);
+	pthread_join(xbee_dev->rx_thread_tid, NULL);
+	printk(KERN_DEBUG "%s(): rx thread ended\n",__func__);
+	return 1;
+}
+
+#endif /* !__KERNEL__ */
+
+#ifndef __KERNEL__
+int main(int argc, char *argv[]){
+	int ret = 0;
+	_api_frame_t *api_frame = NULL;
+	struct xbee_device *xbee_dev = xbee_device_new();
+
+	if(argc > 2)
+	{
+		xbee_dev->tty_path = argv[1];
+	}
+	else
+	{
+		printk(KERN_ERR "Usage: %s <tty device> <receive>|<send>\n",argv[0]);
+		return 1;
+	}
+
+	if(xbee_device_init(xbee_dev) < 0)
+	{
+		printk(KERN_ERR "%s(): error in init\n",__func__);
+		return 1;
+	}
+
+	xbee_start_rx_thread(xbee_dev);
+
+	if(!strcmp("send_TR",argv[2])){
+		//uint8_t addr[XBEE_ADDR_LEN] = {0x00,0x13,0xA2,0x00,0x40,0x0A,0x01,0x27};
+		//uint8_t addr[XBEE_ADDR_LEN] = {0x00,0x13,0xA2,0x00,0x40,0x8B,0xBA,0xCD};
+		//13:A2:00:40:8B:BA:CD:FF
+		uint8_t addr[XBEE_ADDR_LEN] = {0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF};
+		uint8_t payload[8] = {'T','x','D','a','t','a','0','A'};
+
+		xbee_dev->frame_id_counter = 0x01;
+		api_frame = _api_frame_new_transmit_request(xbee_dev,addr,0x00,payload,8);
+		_api_frame_print(api_frame);
+
+		ret = xbee_send(xbee_dev,api_frame);
+		printk(KERN_DEBUG "%s: xbee_send ret: %d\n", __func__,ret);
+
+		_api_frame_free(api_frame);
+
+	} else if(!strcmp("send_ATAP1",argv[2])){
+			xbee_dev->frame_id_counter = 0x01;
+			api_frame = _api_frame_new_at_command_u8(xbee_dev,"AP",0);
+			_api_frame_print(api_frame);
+
+			ret = xbee_send(xbee_dev,api_frame);
+			printk(KERN_DEBUG "%s: xbee_send ret: %d\n", __func__,ret);
+
+			_api_frame_free(api_frame);
+	} else if(!strcmp("addr",argv[2])){
+		uint8_t addr[XBEE_ADDR_LEN] = {};
+		xbee_ieee_address(xbee_dev,addr);
+	} else if(!strcmp("receive",argv[2])){
+		sleep(7);
+	}
+
+	xbee_stop_rx_thread(xbee_dev);
+
+//	xbee_receive(xbee_dev,exTR40esc,sizeof(exTR40esc));
+//
+//	xbee_receive(xbee_dev,teste2,sizeof(teste2));
+//
+//	xbee_receive(xbee_dev,at_cmd_response_BD,sizeof(at_cmd_response_BD));
+//
+//	xbee_receive(xbee_dev,at_cmd_response_SH,sizeof(at_cmd_response_SH));
+//	xbee_receive(xbee_dev,at_cmd_response_SL,sizeof(at_cmd_response_SL));
+//
+//	xbee_receive(xbee_dev,modem_status_hw_reset,sizeof(modem_status_hw_reset));
+//	xbee_receive(xbee_dev,modem_status_timer_reset,sizeof(modem_status_timer_reset));
+//	xbee_receive(xbee_dev,modem_status_net_woke_up,sizeof(modem_status_net_woke_up));
+//	xbee_receive(xbee_dev,modem_status_net_went2sleep,sizeof(modem_status_net_went2sleep));
+//
+//	xbee_receive(xbee_dev,transmit_status2,sizeof(transmit_status2));
+//
+//	xbee_receive(xbee_dev,node_id_indicator,sizeof(node_id_indicator));
+//
+//	xbee_receive(xbee_dev,receive_packet,sizeof(receive_packet));
+//	xbee_receive(xbee_dev,explicit_rx_indicator,sizeof(explicit_rx_indicator));
+
+//	uint8_t somecommand1[] = {0x7E ,0x00 ,0x16 ,0x10 ,0x01 ,0x00 ,0x13 ,0xA2 ,0x00 ,0x40 ,0x0A ,0x01 ,0x27 ,0xFF ,0xFE ,0x00 ,0x00 ,0x54 ,0x78 ,0x44 ,0x61 ,0x74 ,0x61 ,0x30 ,0x41 ,0x13 };
+//	uint8_t somecommand[] = {0x7D, 0x5E ,0x00 ,0x16 ,0x10 ,0x01 ,0x00 ,0x7D, 0x33 ,0xA2 ,0x00 ,0x40 ,0x0A ,0x01 ,0x27 ,0xFF ,0xFE ,0x00 ,0x00 ,0x54 ,0x78 ,0x44 ,0x61 ,0x74 ,0x61 ,0x30 ,0x41 ,0x7D, 0x33 };
+
+//	xbee_dev->escaped_mode = 0;
+//	xbee_receive(xbee_dev,somecommand1,sizeof(somecommand1));
+
+//	xbee_dev->escaped_mode = 1;
+//	xbee_receive(xbee_dev,somecommand,sizeof(somecommand));
+
+//	api_frame = _api_frame_new_at_command(xbee_dev,"NH");
+//	_api_frame_print(api_frame);
+//	_api_frame_free(api_frame);
+//
+//	api_frame = _api_frame_new_at_command_u8(xbee_dev,"BD",0x10);
+//	_api_frame_print(api_frame);
+//	_api_frame_free(api_frame);
+//
+//	uint8_t args[4] = {0xAA,0xBB,0xCC,0xDD};
+//	api_frame = _api_frame_new_at_command_u32(xbee_dev,"BD",args);
+//	_api_frame_print(api_frame);
+//	_api_frame_free(api_frame);
+//
+//	uint8_t addr[XBEE_ADDR_LEN] = {0x00,0x13,0xA2,0x00,0x40,0x0A,0x01,0x27};
+//	uint8_t payload[8] = {'T','x','D','a','t','a','0','A'};
+//
+//	xbee_dev->frame_id_counter = 0x01;
+//	api_frame = _api_frame_new_transmit_request(xbee_dev,addr,0x00,payload,8);
+//	_api_frame_print(api_frame);
+//
+//	ret = xbee_send(xbee_dev,api_frame);
+//	printk(KERN_DEBUG "%s: xbee_send ret: %d\n", __func__,ret);
+
+//	uint16_t len = 0;
+//	uint8_t *raw_frame = _api_frame_to_raw(api_frame,&len);
+//	int i = 0;
+//	uint8_t raw_byte = 0;
+//	printf("Dump: uint8_t somecommand[] = {");
+//	unsigned char *data = (unsigned char *) raw_frame;
+//	for(i = 0;i<len;i++){
+//		if(i)
+//			printf(",");
+//		raw_byte = ((unsigned char)*(raw_frame+i));
+//		if(xbee_dev->escaped_mode && escape_required(raw_byte))
+//		{
+//			printf("0x%02X, ",XBEE_ESCAPE);
+//			raw_byte = raw_byte^0x20;
+//		}
+//		printf("0x%02X ",raw_byte);
+//	}
+//	printf("};\n");
+//	if(raw_frame) free(raw_frame);
+//	_api_frame_free(api_frame);
+
+	xbee_device_release(xbee_dev);
+	return 0;
+}
+
+#endif /* !__KERNEL__ */
diff --git a/include/uapi/linux/tty.h b/include/uapi/linux/tty.h
index dac199a..96233b1 100644
--- a/include/uapi/linux/tty.h
+++ b/include/uapi/linux/tty.h
@@ -34,5 +34,6 @@
 #define N_TI_WL		22	/* for TI's WL BT, FM, GPS combo chips */
 #define N_TRACESINK	23	/* Trace data routing for MIPI P1149.7 */
 #define N_TRACEROUTER	24	/* Trace data routing for MIPI P1149.7 */
+#define N_IEEE802154	25	/* Serial / USB serial IEEE802154.4 devices */
 
 #endif /* _UAPI_LINUX_TTY_H */
-- 
1.8.3.2

